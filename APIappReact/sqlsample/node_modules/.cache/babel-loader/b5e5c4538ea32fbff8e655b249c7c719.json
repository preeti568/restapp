{"ast":null,"code":"'use strict';\n/* const FIGURE = {\r\n  INTERIOR_RING: 0x00,\r\n  STROKE: 0x01,\r\n  EXTERIOR_RING: 0x02\r\n};\r\n\r\nconst FIGURE_V2 = {\r\n  POINT: 0x00,\r\n  LINE: 0x01,\r\n  ARC: 0x02,\r\n  COMPOSITE_CURVE: 0x03\r\n};\r\n\r\nconst SHAPE = {\r\n  POINT: 0x01,\r\n  LINESTRING: 0x02,\r\n  POLYGON: 0x03,\r\n  MULTIPOINT: 0x04,\r\n  MULTILINESTRING: 0x05,\r\n  MULTIPOLYGON: 0x06,\r\n  GEOMETRY_COLLECTION: 0x07\r\n};\r\n\r\nconst SHAPE_V2 = {\r\n  POINT: 0x01,\r\n  LINESTRING: 0x02,\r\n  POLYGON: 0x03,\r\n  MULTIPOINT: 0x04,\r\n  MULTILINESTRING: 0x05,\r\n  MULTIPOLYGON: 0x06,\r\n  GEOMETRY_COLLECTION: 0x07,\r\n  CIRCULAR_STRING: 0x08,\r\n  COMPOUND_CURVE: 0x09,\r\n  CURVE_POLYGON: 0x0A,\r\n  FULL_GLOBE: 0x0B\r\n};\r\n\r\nconst SEGMENT = {\r\n  LINE: 0x00,\r\n  ARC: 0x01,\r\n  FIRST_LINE: 0x02,\r\n  FIRST_ARC: 0x03\r\n}; */\n\nclass Point {\n  constructor() {\n    this.x = 0;\n    this.y = 0;\n    this.z = null;\n    this.m = null;\n  }\n\n}\n\nconst parsePoints = (buffer, count) => {\n  // s2.1.5 + s2.1.6\n  const points = [];\n\n  if (count < 1) {\n    return points;\n  }\n\n  for (let i = 1; i <= count; i++) {\n    const point = new Point();\n    points.push(point);\n    point.x = buffer.readDoubleLE(buffer.position);\n    point.y = buffer.readDoubleLE(buffer.position + 8);\n    buffer.position += 16;\n  }\n\n  return points;\n};\n\nconst parseZ = (buffer, points) => {\n  // s2.1.1 + s.2.1.2\n  if (points < 1) {\n    return;\n  }\n\n  points.forEach(point => {\n    point.z = buffer.readDoubleLE(buffer.position);\n    buffer.position += 8;\n  });\n};\n\nconst parseM = (buffer, points) => {\n  // s2.1.1 + s.2.1.2\n  if (points < 1) {\n    return;\n  }\n\n  points.forEach(point => {\n    point.m = buffer.readDoubleLE(buffer.position);\n    buffer.position += 8;\n  });\n};\n\nconst parseFigures = (buffer, count, properties) => {\n  // s2.1.3\n  const figures = [];\n\n  if (count < 1) {\n    return figures;\n  }\n\n  if (properties.P) {\n    figures.push({\n      attribute: 0x01,\n      pointOffset: 0\n    });\n  } else if (properties.L) {\n    figures.push({\n      attribute: 0x01,\n      pointOffset: 0\n    });\n  } else {\n    for (let i = 1; i <= count; i++) {\n      figures.push({\n        attribute: buffer.readUInt8(buffer.position),\n        pointOffset: buffer.readInt32LE(buffer.position + 1)\n      });\n      buffer.position += 5;\n    }\n  }\n\n  return figures;\n};\n\nconst parseShapes = (buffer, count, properties) => {\n  // s2.1.4\n  const shapes = [];\n\n  if (count < 1) {\n    return shapes;\n  }\n\n  if (properties.P) {\n    shapes.push({\n      parentOffset: -1,\n      figureOffset: 0,\n      type: 0x01\n    });\n  } else if (properties.L) {\n    shapes.push({\n      parentOffset: -1,\n      figureOffset: 0,\n      type: 0x02\n    });\n  } else {\n    for (let i = 1; i <= count; i++) {\n      shapes.push({\n        parentOffset: buffer.readInt32LE(buffer.position),\n        figureOffset: buffer.readInt32LE(buffer.position + 4),\n        type: buffer.readUInt8(buffer.position + 8)\n      });\n      buffer.position += 9;\n    }\n  }\n\n  return shapes;\n};\n\nconst parseSegments = (buffer, count) => {\n  // s2.1.7\n  const segments = [];\n\n  if (count < 1) {\n    return segments;\n  }\n\n  for (let i = 1; i <= count; i++) {\n    segments.push({\n      type: buffer.readUInt8(buffer.position)\n    });\n    buffer.position++;\n  }\n\n  return segments;\n};\n\nconst parseGeography = buffer => {\n  // s2.1.1 + s.2.1.2\n  const srid = buffer.readInt32LE(0);\n\n  if (srid === -1) {\n    return null;\n  }\n\n  const value = {\n    srid,\n    version: buffer.readUInt8(4)\n  };\n  const flags = buffer.readUInt8(5);\n  buffer.position = 6; // console.log(\"srid\", srid)\n  // console.log(\"version\", version)\n\n  const properties = {\n    Z: (flags & 1 << 0) > 0,\n    M: (flags & 1 << 1) > 0,\n    V: (flags & 1 << 2) > 0,\n    P: (flags & 1 << 3) > 0,\n    L: (flags & 1 << 4) > 0\n  };\n\n  if (value.version === 2) {\n    properties.H = (flags & 1 << 3) > 0;\n  } // console.log(\"properties\", properties);\n\n\n  let numberOfPoints;\n\n  if (properties.P) {\n    numberOfPoints = 1;\n  } else if (properties.L) {\n    numberOfPoints = 2;\n  } else {\n    numberOfPoints = buffer.readUInt32LE(buffer.position);\n    buffer.position += 4;\n  } // console.log(\"numberOfPoints\", numberOfPoints)\n\n\n  value.points = parsePoints(buffer, numberOfPoints);\n\n  if (properties.Z) {\n    parseZ(buffer, value.points);\n  }\n\n  if (properties.M) {\n    parseM(buffer, value.points);\n  } // console.log(\"points\", points)\n\n\n  let numberOfFigures;\n\n  if (properties.P) {\n    numberOfFigures = 1;\n  } else if (properties.L) {\n    numberOfFigures = 1;\n  } else {\n    numberOfFigures = buffer.readUInt32LE(buffer.position);\n    buffer.position += 4;\n  } // console.log(\"numberOfFigures\", numberOfFigures)\n\n\n  value.figures = parseFigures(buffer, numberOfFigures, properties); // console.log(\"figures\", figures)\n\n  let numberOfShapes;\n\n  if (properties.P) {\n    numberOfShapes = 1;\n  } else if (properties.L) {\n    numberOfShapes = 1;\n  } else {\n    numberOfShapes = buffer.readUInt32LE(buffer.position);\n    buffer.position += 4;\n  } // console.log(\"numberOfShapes\", numberOfShapes)\n\n\n  value.shapes = parseShapes(buffer, numberOfShapes, properties); // console.log( \"shapes\", shapes)\n\n  if (value.version === 2) {\n    const numberOfSegments = buffer.readUInt32LE(buffer.position);\n    buffer.position += 4; // console.log(\"numberOfSegments\", numberOfSegments)\n\n    value.segments = parseSegments(buffer, numberOfSegments); // console.log(\"segments\", segments)\n  } else {\n    value.segments = [];\n  }\n\n  return value;\n};\n\nmodule.exports.PARSERS = {\n  geography(buffer) {\n    return parseGeography(buffer);\n  },\n\n  geometry(buffer) {\n    return parseGeography(buffer);\n  }\n\n};","map":{"version":3,"sources":["C:/Projects/sqlsample/node_modules/mssql/lib/udt.js"],"names":["Point","constructor","x","y","z","m","parsePoints","buffer","count","points","i","point","push","readDoubleLE","position","parseZ","forEach","parseM","parseFigures","properties","figures","P","attribute","pointOffset","L","readUInt8","readInt32LE","parseShapes","shapes","parentOffset","figureOffset","type","parseSegments","segments","parseGeography","srid","value","version","flags","Z","M","V","H","numberOfPoints","readUInt32LE","numberOfFigures","numberOfShapes","numberOfSegments","module","exports","PARSERS","geography","geometry"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\n/* const FIGURE = {\r\n  INTERIOR_RING: 0x00,\r\n  STROKE: 0x01,\r\n  EXTERIOR_RING: 0x02\r\n};\r\n\r\nconst FIGURE_V2 = {\r\n  POINT: 0x00,\r\n  LINE: 0x01,\r\n  ARC: 0x02,\r\n  COMPOSITE_CURVE: 0x03\r\n};\r\n\r\nconst SHAPE = {\r\n  POINT: 0x01,\r\n  LINESTRING: 0x02,\r\n  POLYGON: 0x03,\r\n  MULTIPOINT: 0x04,\r\n  MULTILINESTRING: 0x05,\r\n  MULTIPOLYGON: 0x06,\r\n  GEOMETRY_COLLECTION: 0x07\r\n};\r\n\r\nconst SHAPE_V2 = {\r\n  POINT: 0x01,\r\n  LINESTRING: 0x02,\r\n  POLYGON: 0x03,\r\n  MULTIPOINT: 0x04,\r\n  MULTILINESTRING: 0x05,\r\n  MULTIPOLYGON: 0x06,\r\n  GEOMETRY_COLLECTION: 0x07,\r\n  CIRCULAR_STRING: 0x08,\r\n  COMPOUND_CURVE: 0x09,\r\n  CURVE_POLYGON: 0x0A,\r\n  FULL_GLOBE: 0x0B\r\n};\r\n\r\nconst SEGMENT = {\r\n  LINE: 0x00,\r\n  ARC: 0x01,\r\n  FIRST_LINE: 0x02,\r\n  FIRST_ARC: 0x03\r\n}; */\r\n\r\nclass Point {\r\n  constructor () {\r\n    this.x = 0\r\n    this.y = 0\r\n    this.z = null\r\n    this.m = null\r\n  }\r\n}\r\n\r\nconst parsePoints = (buffer, count) => {\r\n  // s2.1.5 + s2.1.6\r\n\r\n  const points = []\r\n  if (count < 1) {\r\n    return points\r\n  }\r\n\r\n  for (let i = 1; i <= count; i++) {\r\n    const point = new Point()\r\n    points.push(point)\r\n    point.x = buffer.readDoubleLE(buffer.position)\r\n    point.y = buffer.readDoubleLE(buffer.position + 8)\r\n    buffer.position += 16\r\n  }\r\n\r\n  return points\r\n}\r\n\r\nconst parseZ = (buffer, points) => {\r\n  // s2.1.1 + s.2.1.2\r\n\r\n  if (points < 1) {\r\n    return\r\n  }\r\n\r\n  points.forEach(point => {\r\n    point.z = buffer.readDoubleLE(buffer.position)\r\n    buffer.position += 8\r\n  })\r\n}\r\n\r\nconst parseM = (buffer, points) => {\r\n  // s2.1.1 + s.2.1.2\r\n\r\n  if (points < 1) {\r\n    return\r\n  }\r\n\r\n  points.forEach(point => {\r\n    point.m = buffer.readDoubleLE(buffer.position)\r\n    buffer.position += 8\r\n  })\r\n}\r\n\r\nconst parseFigures = (buffer, count, properties) => {\r\n  // s2.1.3\r\n\r\n  const figures = []\r\n  if (count < 1) {\r\n    return figures\r\n  }\r\n\r\n  if (properties.P) {\r\n    figures.push({\r\n      attribute: 0x01,\r\n      pointOffset: 0\r\n    })\r\n  } else if (properties.L) {\r\n    figures.push({\r\n      attribute: 0x01,\r\n      pointOffset: 0\r\n    })\r\n  } else {\r\n    for (let i = 1; i <= count; i++) {\r\n      figures.push({\r\n        attribute: buffer.readUInt8(buffer.position),\r\n        pointOffset: buffer.readInt32LE(buffer.position + 1)\r\n      })\r\n\r\n      buffer.position += 5\r\n    }\r\n  }\r\n\r\n  return figures\r\n}\r\n\r\nconst parseShapes = (buffer, count, properties) => {\r\n  // s2.1.4\r\n\r\n  const shapes = []\r\n  if (count < 1) {\r\n    return shapes\r\n  }\r\n\r\n  if (properties.P) {\r\n    shapes.push({\r\n      parentOffset: -1,\r\n      figureOffset: 0,\r\n      type: 0x01\r\n    })\r\n  } else if (properties.L) {\r\n    shapes.push({\r\n      parentOffset: -1,\r\n      figureOffset: 0,\r\n      type: 0x02\r\n    })\r\n  } else {\r\n    for (let i = 1; i <= count; i++) {\r\n      shapes.push({\r\n        parentOffset: buffer.readInt32LE(buffer.position),\r\n        figureOffset: buffer.readInt32LE(buffer.position + 4),\r\n        type: buffer.readUInt8(buffer.position + 8)\r\n      })\r\n\r\n      buffer.position += 9\r\n    }\r\n  }\r\n\r\n  return shapes\r\n}\r\n\r\nconst parseSegments = (buffer, count) => {\r\n  // s2.1.7\r\n\r\n  const segments = []\r\n  if (count < 1) {\r\n    return segments\r\n  }\r\n\r\n  for (let i = 1; i <= count; i++) {\r\n    segments.push({ type: buffer.readUInt8(buffer.position) })\r\n\r\n    buffer.position++\r\n  }\r\n\r\n  return segments\r\n}\r\n\r\nconst parseGeography = buffer => {\r\n  // s2.1.1 + s.2.1.2\r\n\r\n  const srid = buffer.readInt32LE(0)\r\n  if (srid === -1) {\r\n    return null\r\n  }\r\n\r\n  const value = {\r\n    srid,\r\n    version: buffer.readUInt8(4)\r\n  }\r\n\r\n  const flags = buffer.readUInt8(5)\r\n  buffer.position = 6\r\n\r\n  // console.log(\"srid\", srid)\r\n  // console.log(\"version\", version)\r\n\r\n  const properties = {\r\n    Z: (flags & (1 << 0)) > 0,\r\n    M: (flags & (1 << 1)) > 0,\r\n    V: (flags & (1 << 2)) > 0,\r\n    P: (flags & (1 << 3)) > 0,\r\n    L: (flags & (1 << 4)) > 0\r\n  }\r\n\r\n  if (value.version === 2) {\r\n    properties.H = (flags & (1 << 3)) > 0\r\n  }\r\n\r\n  // console.log(\"properties\", properties);\r\n\r\n  let numberOfPoints\r\n  if (properties.P) {\r\n    numberOfPoints = 1\r\n  } else if (properties.L) {\r\n    numberOfPoints = 2\r\n  } else {\r\n    numberOfPoints = buffer.readUInt32LE(buffer.position)\r\n    buffer.position += 4\r\n  }\r\n\r\n  // console.log(\"numberOfPoints\", numberOfPoints)\r\n\r\n  value.points = parsePoints(buffer, numberOfPoints)\r\n\r\n  if (properties.Z) {\r\n    parseZ(buffer, value.points)\r\n  }\r\n\r\n  if (properties.M) {\r\n    parseM(buffer, value.points)\r\n  }\r\n\r\n  // console.log(\"points\", points)\r\n\r\n  let numberOfFigures\r\n  if (properties.P) {\r\n    numberOfFigures = 1\r\n  } else if (properties.L) {\r\n    numberOfFigures = 1\r\n  } else {\r\n    numberOfFigures = buffer.readUInt32LE(buffer.position)\r\n    buffer.position += 4\r\n  }\r\n\r\n  // console.log(\"numberOfFigures\", numberOfFigures)\r\n\r\n  value.figures = parseFigures(buffer, numberOfFigures, properties)\r\n\r\n  // console.log(\"figures\", figures)\r\n\r\n  let numberOfShapes\r\n  if (properties.P) {\r\n    numberOfShapes = 1\r\n  } else if (properties.L) {\r\n    numberOfShapes = 1\r\n  } else {\r\n    numberOfShapes = buffer.readUInt32LE(buffer.position)\r\n    buffer.position += 4\r\n  }\r\n\r\n  // console.log(\"numberOfShapes\", numberOfShapes)\r\n\r\n  value.shapes = parseShapes(buffer, numberOfShapes, properties)\r\n\r\n  // console.log( \"shapes\", shapes)\r\n\r\n  if (value.version === 2) {\r\n    const numberOfSegments = buffer.readUInt32LE(buffer.position)\r\n    buffer.position += 4\r\n\r\n    // console.log(\"numberOfSegments\", numberOfSegments)\r\n\r\n    value.segments = parseSegments(buffer, numberOfSegments)\r\n\r\n    // console.log(\"segments\", segments)\r\n  } else {\r\n    value.segments = []\r\n  }\r\n\r\n  return value\r\n}\r\n\r\nmodule.exports.PARSERS = {\r\n  geography (buffer) {\r\n    return parseGeography(buffer)\r\n  },\r\n\r\n  geometry (buffer) {\r\n    return parseGeography(buffer)\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}