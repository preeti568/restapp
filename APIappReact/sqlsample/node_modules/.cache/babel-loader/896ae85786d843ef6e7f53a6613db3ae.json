{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst PendingOperation_1 = require(\"./PendingOperation\");\n\nconst Resource_1 = require(\"./Resource\");\n\nconst utils_1 = require(\"./utils\");\n\nclass Pool {\n  constructor(opt) {\n    this.destroyed = false;\n    opt = opt || {};\n\n    if (!opt.create) {\n      throw new Error('Tarn: opt.create function most be provided');\n    }\n\n    if (!opt.destroy) {\n      throw new Error('Tarn: opt.destroy function most be provided');\n    }\n\n    if (typeof opt.min !== 'number' || opt.min < 0 || opt.min !== Math.round(opt.min)) {\n      throw new Error('Tarn: opt.min must be an integer >= 0');\n    }\n\n    if (typeof opt.max !== 'number' || opt.max <= 0 || opt.max !== Math.round(opt.max)) {\n      throw new Error('Tarn: opt.max must be an integer > 0');\n    }\n\n    if (opt.min > opt.max) {\n      throw new Error('Tarn: opt.max is smaller than opt.min');\n    }\n\n    if (!utils_1.checkOptionalTime(opt.acquireTimeoutMillis)) {\n      throw new Error('Tarn: invalid opt.acquireTimeoutMillis ' + JSON.stringify(opt.acquireTimeoutMillis));\n    }\n\n    if (!utils_1.checkOptionalTime(opt.createTimeoutMillis)) {\n      throw new Error('Tarn: invalid opt.createTimeoutMillis ' + JSON.stringify(opt.createTimeoutMillis));\n    }\n\n    if (!utils_1.checkOptionalTime(opt.destroyTimeoutMillis)) {\n      throw new Error('Tarn: invalid opt.destroyTimeoutMillis ' + JSON.stringify(opt.destroyTimeoutMillis));\n    }\n\n    if (!utils_1.checkOptionalTime(opt.idleTimeoutMillis)) {\n      throw new Error('Tarn: invalid opt.idleTimeoutMillis ' + JSON.stringify(opt.idleTimeoutMillis));\n    }\n\n    if (!utils_1.checkOptionalTime(opt.reapIntervalMillis)) {\n      throw new Error('Tarn: invalid opt.reapIntervalMillis ' + JSON.stringify(opt.reapIntervalMillis));\n    }\n\n    if (!utils_1.checkOptionalTime(opt.createRetryIntervalMillis)) {\n      throw new Error('Tarn: invalid opt.createRetryIntervalMillis ' + JSON.stringify(opt.createRetryIntervalMillis));\n    }\n\n    this.creator = opt.create;\n    this.destroyer = opt.destroy;\n    this.validate = typeof opt.validate === 'function' ? opt.validate : () => true;\n\n    this.log = opt.log || (() => {});\n\n    this.acquireTimeoutMillis = opt.acquireTimeoutMillis || 30000;\n    this.createTimeoutMillis = opt.createTimeoutMillis || 30000;\n    this.destroyTimeoutMillis = opt.destroyTimeoutMillis || 5000;\n    this.idleTimeoutMillis = opt.idleTimeoutMillis || 30000;\n    this.reapIntervalMillis = opt.reapIntervalMillis || 1000;\n    this.createRetryIntervalMillis = opt.createRetryIntervalMillis || 200;\n    this.propagateCreateError = !!opt.propagateCreateError;\n    this.min = opt.min;\n    this.max = opt.max;\n    this.used = [];\n    this.free = [];\n    this.pendingCreates = [];\n    this.pendingAcquires = [];\n    this.destroyed = false;\n    this.interval = null;\n  }\n\n  numUsed() {\n    return this.used.length;\n  }\n\n  numFree() {\n    return this.free.length;\n  }\n\n  numPendingAcquires() {\n    return this.pendingAcquires.length;\n  }\n\n  numPendingCreates() {\n    return this.pendingCreates.length;\n  }\n\n  acquire() {\n    const pendingAcquire = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);\n    this.pendingAcquires.push(pendingAcquire); // If the acquire fails for whatever reason\n    // remove it from the pending queue.\n\n    pendingAcquire.promise = pendingAcquire.promise.catch(err => {\n      remove(this.pendingAcquires, pendingAcquire);\n      return Promise.reject(err);\n    });\n\n    this._tryAcquireOrCreate();\n\n    return pendingAcquire;\n  }\n\n  release(resource) {\n    for (let i = 0, l = this.used.length; i < l; ++i) {\n      const used = this.used[i];\n\n      if (used.resource === resource) {\n        this.used.splice(i, 1);\n        this.free.push(used.resolve());\n\n        this._tryAcquireOrCreate();\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  isEmpty() {\n    return [this.numFree(), this.numUsed(), this.numPendingAcquires(), this.numPendingCreates()].reduce((total, value) => total + value) === 0;\n  }\n\n  check() {\n    const timestamp = utils_1.now();\n    const newFree = [];\n    const minKeep = this.min - this.used.length;\n    const maxDestroy = this.free.length - minKeep;\n    let numDestroyed = 0;\n    this.free.forEach(free => {\n      if (utils_1.duration(timestamp, free.timestamp) > this.idleTimeoutMillis && numDestroyed < maxDestroy) {\n        numDestroyed++;\n\n        this._destroy(free.resource);\n      } else {\n        newFree.push(free);\n      }\n    });\n    this.free = newFree; // Pool is completely empty, stop reaping.\n    // Next .acquire will start reaping interval again.\n\n    if (this.isEmpty()) {\n      this._stopReaping();\n    }\n  }\n\n  destroy() {\n    this._stopReaping();\n\n    this.destroyed = true; // First wait for all the pending creates get ready.\n\n    return utils_1.reflect(Promise.all(this.pendingCreates.map(create => utils_1.reflect(create.promise))).then(() => {\n      // Wait for all the used resources to be freed.\n      return Promise.all(this.used.map(used => utils_1.reflect(used.promise)));\n    }).then(() => {\n      // Abort all pending acquires.\n      return Promise.all(this.pendingAcquires.map(acquire => {\n        acquire.abort();\n        return utils_1.reflect(acquire.promise);\n      }));\n    }).then(() => {\n      // Now we can destroy all the freed resources.\n      return Promise.all(this.free.map(free => utils_1.reflect(this._destroy(free.resource))));\n    }).then(() => {\n      this.free = [];\n      this.pendingAcquires = [];\n    }));\n  }\n\n  _tryAcquireOrCreate() {\n    if (this.destroyed) {\n      return;\n    }\n\n    if (this._hasFreeResources()) {\n      this._doAcquire();\n    } else if (this._shouldCreateMoreResources()) {\n      this._doCreate();\n    }\n  }\n\n  _hasFreeResources() {\n    return this.free.length > 0;\n  }\n\n  _doAcquire() {\n    let didDestroyResources = false;\n\n    while (this._canAcquire()) {\n      const pendingAcquire = this.pendingAcquires[0];\n      const free = this.free[this.free.length - 1];\n\n      if (!this._validateResource(free.resource)) {\n        this.free.pop();\n\n        this._destroy(free.resource);\n\n        didDestroyResources = true;\n        continue;\n      }\n\n      this.pendingAcquires.shift();\n      this.free.pop();\n      this.used.push(free.resolve()); //At least one active resource, start reaping\n\n      this._startReaping();\n\n      pendingAcquire.resolve(free.resource);\n    } // If we destroyed invalid resources, we may need to create new ones.\n\n\n    if (didDestroyResources) {\n      this._tryAcquireOrCreate();\n    }\n  }\n\n  _canAcquire() {\n    return this.free.length > 0 && this.pendingAcquires.length > 0;\n  }\n\n  _validateResource(resource) {\n    try {\n      return !!this.validate(resource);\n    } catch (err) {\n      // There's nothing we can do here but log the error. This would otherwise\n      // leak out as an unhandled exception.\n      this.log('Tarn: resource validator threw an exception ' + err.stack, 'warn');\n      return false;\n    }\n  }\n\n  _shouldCreateMoreResources() {\n    return this.used.length + this.pendingCreates.length < this.max && this.pendingCreates.length < this.pendingAcquires.length;\n  }\n\n  _doCreate() {\n    const pendingAcquiresBeforeCreate = this.pendingAcquires.slice();\n\n    const pendingCreate = this._create();\n\n    pendingCreate.promise.then(() => {\n      // Not returned on purpose.\n      this._tryAcquireOrCreate();\n\n      return null;\n    }).catch(err => {\n      if (this.propagateCreateError && this.pendingAcquires.length !== 0) {\n        // If propagateCreateError is true, we don't retry the create\n        // but reject the first pending acquire immediately. Intentionally\n        // use `this.pendingAcquires` instead of `pendingAcquiresBeforeCreate`\n        // in case some acquires in pendingAcquiresBeforeCreate have already\n        // been resolved.\n        this.pendingAcquires[0].reject(err);\n      } // Save the create error to all pending acquires so that we can use it\n      // as the error to reject the acquire if it times out.\n\n\n      pendingAcquiresBeforeCreate.forEach(pendingAcquire => {\n        pendingAcquire.possibleTimeoutCause = err;\n      }); // Not returned on purpose.\n\n      utils_1.delay(this.createRetryIntervalMillis).then(() => this._tryAcquireOrCreate());\n    });\n  }\n\n  _create() {\n    const pendingCreate = new PendingOperation_1.PendingOperation(this.createTimeoutMillis);\n    this.pendingCreates.push(pendingCreate);\n    callbackOrPromise(this.creator).then(resource => {\n      remove(this.pendingCreates, pendingCreate);\n      this.free.push(new Resource_1.Resource(resource)); // Not returned on purpose.\n\n      pendingCreate.resolve(resource);\n      return null;\n    }).catch(err => {\n      remove(this.pendingCreates, pendingCreate); // Not returned on purpose.\n\n      pendingCreate.reject(err);\n      return null;\n    });\n    return pendingCreate;\n  }\n\n  _destroy(resource) {\n    try {\n      // this.destroyer can be both synchronous and asynchronous.\n      // When it's synchronous, errors are handled by the try/catch\n      // When it's asynchronous, errors are handled by .catch()\n      const retVal = this.destroyer(resource);\n\n      if (retVal && retVal.then && retVal.catch) {\n        const pendingDestroy = new PendingOperation_1.PendingOperation(this.destroyTimeoutMillis);\n        retVal.then(() => {\n          pendingDestroy.resolve(resource);\n        }).catch(err => {\n          pendingDestroy.reject(err);\n        }); // In case of an error there's nothing we can do here but log it.\n\n        return pendingDestroy.promise.catch(err => this._logError(err));\n      }\n\n      return Promise.resolve(retVal);\n    } catch (err) {\n      // There's nothing we can do here but log the error. This would otherwise\n      // leak out as an unhandled exception.\n      this._logError(err);\n\n      return Promise.resolve();\n    }\n  }\n\n  _logError(err) {\n    this.log('Tarn: resource destroyer threw an exception ' + err.stack, 'warn');\n  }\n\n  _startReaping() {\n    if (!this.interval) {\n      this.interval = setInterval(() => this.check(), this.reapIntervalMillis);\n    }\n  }\n\n  _stopReaping() {\n    if (this.interval !== null) {\n      clearInterval(this.interval);\n    }\n\n    this.interval = null;\n  }\n\n}\n\nexports.Pool = Pool;\n\nfunction remove(arr, item) {\n  var idx = arr.indexOf(item);\n\n  if (idx === -1) {\n    return false;\n  } else {\n    arr.splice(idx, 1);\n    return true;\n  }\n}\n\nfunction callbackOrPromise(func) {\n  return new Promise((resolve, reject) => {\n    const callback = (err, resource) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(resource);\n      }\n    };\n\n    utils_1.tryPromise(() => func(callback)).then(res => {\n      // If the result is falsy, we assume that the callback will\n      // be called instead of interpreting the falsy value as a\n      // result value.\n      if (res) {\n        resolve(res);\n      }\n    }).catch(err => {\n      reject(err);\n    });\n  });\n}","map":{"version":3,"sources":["C:/Projects/sqlsample/node_modules/tarn/lib/Pool.js"],"names":["Object","defineProperty","exports","value","PendingOperation_1","require","Resource_1","utils_1","Pool","constructor","opt","destroyed","create","Error","destroy","min","Math","round","max","checkOptionalTime","acquireTimeoutMillis","JSON","stringify","createTimeoutMillis","destroyTimeoutMillis","idleTimeoutMillis","reapIntervalMillis","createRetryIntervalMillis","creator","destroyer","validate","log","propagateCreateError","used","free","pendingCreates","pendingAcquires","interval","numUsed","length","numFree","numPendingAcquires","numPendingCreates","acquire","pendingAcquire","PendingOperation","push","promise","catch","err","remove","Promise","reject","_tryAcquireOrCreate","release","resource","i","l","splice","resolve","isEmpty","reduce","total","check","timestamp","now","newFree","minKeep","maxDestroy","numDestroyed","forEach","duration","_destroy","_stopReaping","reflect","all","map","then","abort","_hasFreeResources","_doAcquire","_shouldCreateMoreResources","_doCreate","didDestroyResources","_canAcquire","_validateResource","pop","shift","_startReaping","stack","pendingAcquiresBeforeCreate","slice","pendingCreate","_create","possibleTimeoutCause","delay","callbackOrPromise","Resource","retVal","pendingDestroy","_logError","setInterval","clearInterval","arr","item","idx","indexOf","func","callback","tryPromise","res"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst PendingOperation_1 = require(\"./PendingOperation\");\nconst Resource_1 = require(\"./Resource\");\nconst utils_1 = require(\"./utils\");\nclass Pool {\n    constructor(opt) {\n        this.destroyed = false;\n        opt = opt || {};\n        if (!opt.create) {\n            throw new Error('Tarn: opt.create function most be provided');\n        }\n        if (!opt.destroy) {\n            throw new Error('Tarn: opt.destroy function most be provided');\n        }\n        if (typeof opt.min !== 'number' || opt.min < 0 || opt.min !== Math.round(opt.min)) {\n            throw new Error('Tarn: opt.min must be an integer >= 0');\n        }\n        if (typeof opt.max !== 'number' || opt.max <= 0 || opt.max !== Math.round(opt.max)) {\n            throw new Error('Tarn: opt.max must be an integer > 0');\n        }\n        if (opt.min > opt.max) {\n            throw new Error('Tarn: opt.max is smaller than opt.min');\n        }\n        if (!utils_1.checkOptionalTime(opt.acquireTimeoutMillis)) {\n            throw new Error('Tarn: invalid opt.acquireTimeoutMillis ' + JSON.stringify(opt.acquireTimeoutMillis));\n        }\n        if (!utils_1.checkOptionalTime(opt.createTimeoutMillis)) {\n            throw new Error('Tarn: invalid opt.createTimeoutMillis ' + JSON.stringify(opt.createTimeoutMillis));\n        }\n        if (!utils_1.checkOptionalTime(opt.destroyTimeoutMillis)) {\n            throw new Error('Tarn: invalid opt.destroyTimeoutMillis ' + JSON.stringify(opt.destroyTimeoutMillis));\n        }\n        if (!utils_1.checkOptionalTime(opt.idleTimeoutMillis)) {\n            throw new Error('Tarn: invalid opt.idleTimeoutMillis ' + JSON.stringify(opt.idleTimeoutMillis));\n        }\n        if (!utils_1.checkOptionalTime(opt.reapIntervalMillis)) {\n            throw new Error('Tarn: invalid opt.reapIntervalMillis ' + JSON.stringify(opt.reapIntervalMillis));\n        }\n        if (!utils_1.checkOptionalTime(opt.createRetryIntervalMillis)) {\n            throw new Error('Tarn: invalid opt.createRetryIntervalMillis ' +\n                JSON.stringify(opt.createRetryIntervalMillis));\n        }\n        this.creator = opt.create;\n        this.destroyer = opt.destroy;\n        this.validate = typeof opt.validate === 'function' ? opt.validate : () => true;\n        this.log = opt.log || (() => { });\n        this.acquireTimeoutMillis = opt.acquireTimeoutMillis || 30000;\n        this.createTimeoutMillis = opt.createTimeoutMillis || 30000;\n        this.destroyTimeoutMillis = opt.destroyTimeoutMillis || 5000;\n        this.idleTimeoutMillis = opt.idleTimeoutMillis || 30000;\n        this.reapIntervalMillis = opt.reapIntervalMillis || 1000;\n        this.createRetryIntervalMillis = opt.createRetryIntervalMillis || 200;\n        this.propagateCreateError = !!opt.propagateCreateError;\n        this.min = opt.min;\n        this.max = opt.max;\n        this.used = [];\n        this.free = [];\n        this.pendingCreates = [];\n        this.pendingAcquires = [];\n        this.destroyed = false;\n        this.interval = null;\n    }\n    numUsed() {\n        return this.used.length;\n    }\n    numFree() {\n        return this.free.length;\n    }\n    numPendingAcquires() {\n        return this.pendingAcquires.length;\n    }\n    numPendingCreates() {\n        return this.pendingCreates.length;\n    }\n    acquire() {\n        const pendingAcquire = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);\n        this.pendingAcquires.push(pendingAcquire);\n        // If the acquire fails for whatever reason\n        // remove it from the pending queue.\n        pendingAcquire.promise = pendingAcquire.promise.catch(err => {\n            remove(this.pendingAcquires, pendingAcquire);\n            return Promise.reject(err);\n        });\n        this._tryAcquireOrCreate();\n        return pendingAcquire;\n    }\n    release(resource) {\n        for (let i = 0, l = this.used.length; i < l; ++i) {\n            const used = this.used[i];\n            if (used.resource === resource) {\n                this.used.splice(i, 1);\n                this.free.push(used.resolve());\n                this._tryAcquireOrCreate();\n                return true;\n            }\n        }\n        return false;\n    }\n    isEmpty() {\n        return ([this.numFree(), this.numUsed(), this.numPendingAcquires(), this.numPendingCreates()].reduce((total, value) => total + value) === 0);\n    }\n    check() {\n        const timestamp = utils_1.now();\n        const newFree = [];\n        const minKeep = this.min - this.used.length;\n        const maxDestroy = this.free.length - minKeep;\n        let numDestroyed = 0;\n        this.free.forEach(free => {\n            if (utils_1.duration(timestamp, free.timestamp) > this.idleTimeoutMillis &&\n                numDestroyed < maxDestroy) {\n                numDestroyed++;\n                this._destroy(free.resource);\n            }\n            else {\n                newFree.push(free);\n            }\n        });\n        this.free = newFree;\n        // Pool is completely empty, stop reaping.\n        // Next .acquire will start reaping interval again.\n        if (this.isEmpty()) {\n            this._stopReaping();\n        }\n    }\n    destroy() {\n        this._stopReaping();\n        this.destroyed = true;\n        // First wait for all the pending creates get ready.\n        return utils_1.reflect(Promise.all(this.pendingCreates.map(create => utils_1.reflect(create.promise)))\n            .then(() => {\n            // Wait for all the used resources to be freed.\n            return Promise.all(this.used.map(used => utils_1.reflect(used.promise)));\n        })\n            .then(() => {\n            // Abort all pending acquires.\n            return Promise.all(this.pendingAcquires.map(acquire => {\n                acquire.abort();\n                return utils_1.reflect(acquire.promise);\n            }));\n        })\n            .then(() => {\n            // Now we can destroy all the freed resources.\n            return Promise.all(this.free.map(free => utils_1.reflect(this._destroy(free.resource))));\n        })\n            .then(() => {\n            this.free = [];\n            this.pendingAcquires = [];\n        }));\n    }\n    _tryAcquireOrCreate() {\n        if (this.destroyed) {\n            return;\n        }\n        if (this._hasFreeResources()) {\n            this._doAcquire();\n        }\n        else if (this._shouldCreateMoreResources()) {\n            this._doCreate();\n        }\n    }\n    _hasFreeResources() {\n        return this.free.length > 0;\n    }\n    _doAcquire() {\n        let didDestroyResources = false;\n        while (this._canAcquire()) {\n            const pendingAcquire = this.pendingAcquires[0];\n            const free = this.free[this.free.length - 1];\n            if (!this._validateResource(free.resource)) {\n                this.free.pop();\n                this._destroy(free.resource);\n                didDestroyResources = true;\n                continue;\n            }\n            this.pendingAcquires.shift();\n            this.free.pop();\n            this.used.push(free.resolve());\n            //At least one active resource, start reaping\n            this._startReaping();\n            pendingAcquire.resolve(free.resource);\n        }\n        // If we destroyed invalid resources, we may need to create new ones.\n        if (didDestroyResources) {\n            this._tryAcquireOrCreate();\n        }\n    }\n    _canAcquire() {\n        return this.free.length > 0 && this.pendingAcquires.length > 0;\n    }\n    _validateResource(resource) {\n        try {\n            return !!this.validate(resource);\n        }\n        catch (err) {\n            // There's nothing we can do here but log the error. This would otherwise\n            // leak out as an unhandled exception.\n            this.log('Tarn: resource validator threw an exception ' + err.stack, 'warn');\n            return false;\n        }\n    }\n    _shouldCreateMoreResources() {\n        return (this.used.length + this.pendingCreates.length < this.max &&\n            this.pendingCreates.length < this.pendingAcquires.length);\n    }\n    _doCreate() {\n        const pendingAcquiresBeforeCreate = this.pendingAcquires.slice();\n        const pendingCreate = this._create();\n        pendingCreate.promise\n            .then(() => {\n            // Not returned on purpose.\n            this._tryAcquireOrCreate();\n            return null;\n        })\n            .catch(err => {\n            if (this.propagateCreateError && this.pendingAcquires.length !== 0) {\n                // If propagateCreateError is true, we don't retry the create\n                // but reject the first pending acquire immediately. Intentionally\n                // use `this.pendingAcquires` instead of `pendingAcquiresBeforeCreate`\n                // in case some acquires in pendingAcquiresBeforeCreate have already\n                // been resolved.\n                this.pendingAcquires[0].reject(err);\n            }\n            // Save the create error to all pending acquires so that we can use it\n            // as the error to reject the acquire if it times out.\n            pendingAcquiresBeforeCreate.forEach(pendingAcquire => {\n                pendingAcquire.possibleTimeoutCause = err;\n            });\n            // Not returned on purpose.\n            utils_1.delay(this.createRetryIntervalMillis).then(() => this._tryAcquireOrCreate());\n        });\n    }\n    _create() {\n        const pendingCreate = new PendingOperation_1.PendingOperation(this.createTimeoutMillis);\n        this.pendingCreates.push(pendingCreate);\n        callbackOrPromise(this.creator)\n            .then(resource => {\n            remove(this.pendingCreates, pendingCreate);\n            this.free.push(new Resource_1.Resource(resource));\n            // Not returned on purpose.\n            pendingCreate.resolve(resource);\n            return null;\n        })\n            .catch(err => {\n            remove(this.pendingCreates, pendingCreate);\n            // Not returned on purpose.\n            pendingCreate.reject(err);\n            return null;\n        });\n        return pendingCreate;\n    }\n    _destroy(resource) {\n        try {\n            // this.destroyer can be both synchronous and asynchronous.\n            // When it's synchronous, errors are handled by the try/catch\n            // When it's asynchronous, errors are handled by .catch()\n            const retVal = this.destroyer(resource);\n            if (retVal && retVal.then && retVal.catch) {\n                const pendingDestroy = new PendingOperation_1.PendingOperation(this.destroyTimeoutMillis);\n                retVal\n                    .then(() => {\n                    pendingDestroy.resolve(resource);\n                })\n                    .catch((err) => {\n                    pendingDestroy.reject(err);\n                });\n                // In case of an error there's nothing we can do here but log it.\n                return pendingDestroy.promise.catch(err => this._logError(err));\n            }\n            return Promise.resolve(retVal);\n        }\n        catch (err) {\n            // There's nothing we can do here but log the error. This would otherwise\n            // leak out as an unhandled exception.\n            this._logError(err);\n            return Promise.resolve();\n        }\n    }\n    _logError(err) {\n        this.log('Tarn: resource destroyer threw an exception ' + err.stack, 'warn');\n    }\n    _startReaping() {\n        if (!this.interval) {\n            this.interval = setInterval(() => this.check(), this.reapIntervalMillis);\n        }\n    }\n    _stopReaping() {\n        if (this.interval !== null) {\n            clearInterval(this.interval);\n        }\n        this.interval = null;\n    }\n}\nexports.Pool = Pool;\nfunction remove(arr, item) {\n    var idx = arr.indexOf(item);\n    if (idx === -1) {\n        return false;\n    }\n    else {\n        arr.splice(idx, 1);\n        return true;\n    }\n}\nfunction callbackOrPromise(func) {\n    return new Promise((resolve, reject) => {\n        const callback = (err, resource) => {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve(resource);\n            }\n        };\n        utils_1.tryPromise(() => func(callback))\n            .then(res => {\n            // If the result is falsy, we assume that the callback will\n            // be called instead of interpreting the falsy value as a\n            // result value.\n            if (res) {\n                resolve(res);\n            }\n        })\n            .catch(err => {\n            reject(err);\n        });\n    });\n}\n"]},"metadata":{},"sourceType":"script"}