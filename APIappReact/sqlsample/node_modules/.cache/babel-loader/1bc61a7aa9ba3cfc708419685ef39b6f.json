{"ast":null,"code":"'use strict';\n\nconst URL = require('url').URL;\n\nconst IGNORE_KEYS = ['stream'];\n\nconst oror = function () {\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    if (arguments[i] !== null && arguments[i] !== undefined) {\n      return arguments[i];\n    }\n  }\n};\n\nconst parseConnectionURI = function (uri) {\n  const parsed = new URL(uri);\n  let instance;\n  let user;\n  let password;\n  const path = parsed.pathname.substr(1).split('/');\n\n  if (path.length > 1) {\n    instance = path.shift();\n  }\n\n  if (parsed.username) {\n    const auth = [parsed.username, parsed.password];\n    user = decodeURIComponent(auth.shift());\n    password = decodeURIComponent(auth.join(':'));\n  }\n\n  const port = parsed.port ? `,${parsed.port}` : instance ? `\\\\${instance}` : '';\n  const object = {\n    server: `${parsed.hostname}${port}`,\n    uid: user || '',\n    pwd: password || '',\n    database: path[0]\n  };\n\n  if (parsed.searchParams) {\n    parsed.searchParams.forEach((value, key) => {\n      if (key === 'domain') {\n        object.uid = `${value}\\\\${object.uid}`;\n      } else {\n        object[key] = value;\n      }\n    });\n  }\n\n  Object.defineProperty(object, 'toString', {\n    value() {\n      const out = [];\n\n      for (const key in this) {\n        if (IGNORE_KEYS.indexOf(key) === -1) {\n          out.push(`${key}={${this[key]}}`);\n        }\n      }\n\n      return out.join(';');\n    }\n\n  });\n  return object;\n};\n\nconst parseConnectionString = function (string) {\n  let cursor = 0;\n  let parsing = 'name';\n  let param = null;\n  let buffer = '';\n  let quotes = null;\n  const parsed = {};\n  const original = {};\n  Object.defineProperty(parsed, '__original__', {\n    value: original\n  });\n  Object.defineProperty(parsed, 'toString', {\n    value() {\n      const out = [];\n\n      for (const key in this) {\n        if (IGNORE_KEYS.indexOf(key) === -1) {\n          const esc = original[key].escape || ['', ''];\n          out.push(`${original[key].name}=${esc[0] || ''}${this[key]}${esc[1] || ''}`);\n        }\n      }\n\n      return out.join(';');\n    }\n\n  });\n\n  while (cursor < string.length) {\n    const char = string.charAt(cursor);\n\n    switch (char) {\n      case '=':\n        if (parsing === 'name') {\n          buffer = buffer.trim();\n          param = buffer.toLowerCase();\n          original[param] = {\n            name: buffer\n          };\n          parsing = 'value';\n          buffer = '';\n        } else {\n          buffer += char;\n        }\n\n        break;\n\n      case '\\'':\n      case '\"':\n        if (parsing === 'value') {\n          if (!buffer.trim().length) {\n            // value is wrapped in qotes\n            original[param].escape = [char, char];\n            quotes = char;\n            buffer = '';\n          } else if (quotes) {\n            if (char === quotes) {\n              // found same char as used for wrapping quotes\n              if (char === string.charAt(cursor + 1)) {\n                // escaped quote\n                buffer += char;\n                cursor++;\n              } else {\n                // end of value\n                parsed[param] = buffer;\n                param = null;\n                parsing = null;\n                buffer = '';\n                quotes = null;\n              }\n            } else {\n              buffer += char;\n            }\n          } else {\n            buffer += char;\n          }\n        } else {\n          throw new Error('Invalid connection string.');\n        }\n\n        break;\n\n      case '{':\n        if (parsing === 'value') {\n          if (buffer.trim().length === 0) {\n            // value is wrapped in qotes\n            original[param].escape = ['{', '}'];\n            quotes = '{}';\n            buffer = '';\n          } else {\n            buffer += char;\n          }\n        } else {\n          throw new Error('Invalid connection string.');\n        }\n\n        break;\n\n      case '}':\n        if (parsing === 'value') {\n          if (quotes === '{}') {\n            // end of value\n            parsed[param] = buffer;\n            param = null;\n            parsing = null;\n            buffer = '';\n            quotes = null;\n          } else {\n            buffer += char;\n          }\n        } else {\n          throw new Error('Invalid connection string.');\n        }\n\n        break;\n\n      case ';':\n        if (parsing === 'value') {\n          if (quotes) {\n            buffer += char;\n          } else {\n            // end of value\n            parsed[param] = buffer;\n            param = null;\n            parsing = 'name';\n            buffer = '';\n          }\n        } else {\n          buffer = '';\n          parsing = 'name';\n        }\n\n        break;\n\n      default:\n        buffer += char;\n    }\n\n    cursor++;\n  }\n\n  if (parsing === 'value') {\n    // end of value\n    parsed[param] = buffer;\n  }\n\n  return parsed;\n};\n\nconst resolveConnectionString = function (string, driver) {\n  const parsed = /^(mssql|tedious|msnodesql|tds):\\/\\//i.test(string) ? parseConnectionURI(string) : parseConnectionString(string);\n  const stream = (parsed.stream || '').toLowerCase();\n  const encrypt = (parsed.encrypt || '').toLowerCase();\n\n  if (driver === 'msnodesqlv8') {\n    parsed.driver = 'SQL Server Native Client 11.0';\n\n    if (parsed.__original__) {\n      parsed.__original__.driver = {\n        name: 'Driver',\n        escape: ['{', '}']\n      };\n    }\n\n    return {\n      connectionString: parsed.toString()\n    };\n  }\n\n  let user = parsed.uid || parsed.uid || parsed['user id'];\n  let server = parsed.server || parsed.address || parsed.addr || parsed['data source'] || parsed['network address'];\n  const config = {\n    password: oror(parsed.pwd, parsed.password),\n    database: oror(parsed.database, parsed['initial catalog']),\n    connectionTimeout: oror(parsed.connectionTimeout, parsed.timeout, parsed['connect timeout'], parsed['connection timeout']),\n    requestTimeout: oror(parsed.requestTimeout, parsed['request timeout']),\n    stream: stream === 'true' || stream === 'yes' || stream === '1',\n    options: {\n      readOnlyIntent: parsed.applicationintent && parsed.applicationintent.toLowerCase() === 'readonly',\n      encrypt: encrypt === 'true' || encrypt === 'yes' || encrypt === '1'\n    }\n  };\n\n  if (parsed.useUTC != null) {\n    const utc = parsed.useUTC.toLowerCase();\n    config.options.useUTC = utc === 'true' || utc === 'yes' || utc === '1';\n  }\n\n  if (config.connectionTimeout != null) {\n    config.connectionTimeout = parseInt(config.connectionTimeout, 10) * 1000;\n  }\n\n  if (config.requestTimeout != null) {\n    config.requestTimeout = parseInt(config.requestTimeout, 10);\n  }\n\n  if (parsed.multisubnetfailover != null) {\n    config.options.multiSubnetFailover = parsed.multisubnetfailover.toLowerCase() === 'true';\n  }\n\n  if (/^(.*)\\\\(.*)$/.exec(user)) {\n    config.domain = RegExp.$1;\n    user = RegExp.$2;\n  }\n\n  if (server) {\n    server = server.trim();\n\n    if (/^np:/i.test(server)) {\n      throw new Error('Connection via Named Pipes is not supported.');\n    }\n\n    if (/^tcp:/i.test(server)) {\n      server = server.substr(4);\n    }\n\n    if (/^(.*)\\\\(.*)$/.exec(server)) {\n      server = RegExp.$1;\n      config.options.instanceName = RegExp.$2;\n    }\n\n    if (/^(.*),(.*)$/.exec(server)) {\n      server = RegExp.$1.trim();\n      config.port = parseInt(RegExp.$2.trim(), 10);\n    }\n\n    if (server === '.' || server === '(.)' || server.toLowerCase() === '(localdb)' || server.toLowerCase() === '(local)') {\n      server = 'localhost';\n    }\n  }\n\n  config.user = user;\n  config.server = server;\n  return config;\n};\n\nmodule.exports = {\n  parse: parseConnectionString,\n  resolve: resolveConnectionString\n};","map":{"version":3,"sources":["C:/Projects/sqlsample/node_modules/mssql/lib/connectionstring.js"],"names":["URL","require","IGNORE_KEYS","oror","i","l","arguments","length","undefined","parseConnectionURI","uri","parsed","instance","user","password","path","pathname","substr","split","shift","username","auth","decodeURIComponent","join","port","object","server","hostname","uid","pwd","database","searchParams","forEach","value","key","Object","defineProperty","out","indexOf","push","parseConnectionString","string","cursor","parsing","param","buffer","quotes","original","esc","escape","name","char","charAt","trim","toLowerCase","Error","resolveConnectionString","driver","test","stream","encrypt","__original__","connectionString","toString","address","addr","config","connectionTimeout","timeout","requestTimeout","options","readOnlyIntent","applicationintent","useUTC","utc","parseInt","multisubnetfailover","multiSubnetFailover","exec","domain","RegExp","$1","$2","instanceName","module","exports","parse","resolve"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst URL = require('url').URL\r\n\r\nconst IGNORE_KEYS = ['stream']\r\nconst oror = function () {\r\n  for (let i = 0, l = arguments.length; i < l; i++) {\r\n    if (arguments[i] !== null && arguments[i] !== undefined) {\r\n      return arguments[i]\r\n    }\r\n  }\r\n}\r\n\r\nconst parseConnectionURI = function (uri) {\r\n  const parsed = new URL(uri)\r\n  let instance\r\n  let user\r\n  let password\r\n\r\n  const path = parsed.pathname.substr(1).split('/')\r\n  if (path.length > 1) {\r\n    instance = path.shift()\r\n  }\r\n\r\n  if (parsed.username) {\r\n    const auth = [parsed.username, parsed.password]\r\n    user = decodeURIComponent(auth.shift())\r\n    password = decodeURIComponent(auth.join(':'))\r\n  }\r\n\r\n  const port = parsed.port ? `,${parsed.port}` : (instance ? `\\\\${instance}` : '')\r\n  const object = {\r\n    server: `${parsed.hostname}${port}`,\r\n    uid: user || '',\r\n    pwd: password || '',\r\n    database: path[0]\r\n  }\r\n\r\n  if (parsed.searchParams) {\r\n    parsed.searchParams.forEach((value, key) => {\r\n      if (key === 'domain') {\r\n        object.uid = `${value}\\\\${object.uid}`\r\n      } else {\r\n        object[key] = value\r\n      }\r\n    })\r\n  }\r\n\r\n  Object.defineProperty(object, 'toString', {\r\n    value () {\r\n      const out = []\r\n      for (const key in this) {\r\n        if (IGNORE_KEYS.indexOf(key) === -1) {\r\n          out.push(`${key}={${this[key]}}`)\r\n        }\r\n      }\r\n      return out.join(';')\r\n    }\r\n  })\r\n\r\n  return object\r\n}\r\n\r\nconst parseConnectionString = function (string) {\r\n  let cursor = 0\r\n  let parsing = 'name'\r\n  let param = null\r\n  let buffer = ''\r\n  let quotes = null\r\n  const parsed = {}\r\n  const original = {}\r\n\r\n  Object.defineProperty(parsed, '__original__', { value: original })\r\n  Object.defineProperty(parsed, 'toString', {\r\n    value () {\r\n      const out = []\r\n      for (const key in this) {\r\n        if (IGNORE_KEYS.indexOf(key) === -1) {\r\n          const esc = original[key].escape || ['', '']\r\n          out.push(`${original[key].name}=${esc[0] || ''}${this[key]}${esc[1] || ''}`)\r\n        }\r\n      }\r\n      return out.join(';')\r\n    }\r\n  })\r\n\r\n  while (cursor < string.length) {\r\n    const char = string.charAt(cursor)\r\n    switch (char) {\r\n      case '=':\r\n        if (parsing === 'name') {\r\n          buffer = buffer.trim()\r\n          param = buffer.toLowerCase()\r\n          original[param] = { name: buffer }\r\n          parsing = 'value'\r\n          buffer = ''\r\n        } else {\r\n          buffer += char\r\n        }\r\n        break\r\n\r\n      case '\\'': case '\"':\r\n        if (parsing === 'value') {\r\n          if (!buffer.trim().length) {\r\n            // value is wrapped in qotes\r\n            original[param].escape = [char, char]\r\n            quotes = char\r\n            buffer = ''\r\n          } else if (quotes) {\r\n            if (char === quotes) {\r\n              // found same char as used for wrapping quotes\r\n              if (char === string.charAt(cursor + 1)) {\r\n                // escaped quote\r\n                buffer += char\r\n                cursor++\r\n              } else {\r\n                // end of value\r\n                parsed[param] = buffer\r\n                param = null\r\n                parsing = null\r\n                buffer = ''\r\n                quotes = null\r\n              }\r\n            } else {\r\n              buffer += char\r\n            }\r\n          } else {\r\n            buffer += char\r\n          }\r\n        } else {\r\n          throw new Error('Invalid connection string.')\r\n        }\r\n        break\r\n\r\n      case '{':\r\n        if (parsing === 'value') {\r\n          if (buffer.trim().length === 0) {\r\n            // value is wrapped in qotes\r\n            original[param].escape = ['{', '}']\r\n            quotes = '{}'\r\n            buffer = ''\r\n          } else {\r\n            buffer += char\r\n          }\r\n        } else {\r\n          throw new Error('Invalid connection string.')\r\n        }\r\n        break\r\n\r\n      case '}':\r\n        if (parsing === 'value') {\r\n          if (quotes === '{}') {\r\n            // end of value\r\n            parsed[param] = buffer\r\n            param = null\r\n            parsing = null\r\n            buffer = ''\r\n            quotes = null\r\n          } else {\r\n            buffer += char\r\n          }\r\n        } else {\r\n          throw new Error('Invalid connection string.')\r\n        }\r\n        break\r\n\r\n      case ';':\r\n        if (parsing === 'value') {\r\n          if (quotes) {\r\n            buffer += char\r\n          } else {\r\n            // end of value\r\n            parsed[param] = buffer\r\n            param = null\r\n            parsing = 'name'\r\n            buffer = ''\r\n          }\r\n        } else {\r\n          buffer = ''\r\n          parsing = 'name'\r\n        }\r\n        break\r\n\r\n      default:\r\n        buffer += char\r\n    }\r\n\r\n    cursor++\r\n  }\r\n\r\n  if (parsing === 'value') {\r\n    // end of value\r\n    parsed[param] = buffer\r\n  }\r\n\r\n  return parsed\r\n}\r\n\r\nconst resolveConnectionString = function (string, driver) {\r\n  const parsed = /^(mssql|tedious|msnodesql|tds):\\/\\//i.test(string) ? parseConnectionURI(string) : parseConnectionString(string)\r\n  const stream = (parsed.stream || '').toLowerCase()\r\n  const encrypt = (parsed.encrypt || '').toLowerCase()\r\n\r\n  if (driver === 'msnodesqlv8') {\r\n    parsed.driver = 'SQL Server Native Client 11.0'\r\n\r\n    if (parsed.__original__) {\r\n      parsed.__original__.driver = { name: 'Driver', escape: ['{', '}'] }\r\n    }\r\n\r\n    return { connectionString: parsed.toString() }\r\n  }\r\n\r\n  let user = parsed.uid || parsed.uid || parsed['user id']\r\n  let server = parsed.server || parsed.address || parsed.addr || parsed['data source'] || parsed['network address']\r\n\r\n  const config = {\r\n    password: oror(parsed.pwd, parsed.password),\r\n    database: oror(parsed.database, parsed['initial catalog']),\r\n    connectionTimeout: oror(parsed.connectionTimeout, parsed.timeout, parsed['connect timeout'], parsed['connection timeout']),\r\n    requestTimeout: oror(parsed.requestTimeout, parsed['request timeout']),\r\n    stream: stream === 'true' || stream === 'yes' || stream === '1',\r\n    options: {\r\n      readOnlyIntent: parsed.applicationintent && parsed.applicationintent.toLowerCase() === 'readonly',\r\n      encrypt: encrypt === 'true' || encrypt === 'yes' || encrypt === '1'\r\n    }\r\n  }\r\n\r\n  if (parsed.useUTC != null) {\r\n    const utc = parsed.useUTC.toLowerCase()\r\n    config.options.useUTC = utc === 'true' || utc === 'yes' || utc === '1'\r\n  }\r\n  if (config.connectionTimeout != null) {\r\n    config.connectionTimeout = parseInt(config.connectionTimeout, 10) * 1000\r\n  }\r\n  if (config.requestTimeout != null) {\r\n    config.requestTimeout = parseInt(config.requestTimeout, 10)\r\n  }\r\n\r\n  if (parsed.multisubnetfailover != null) {\r\n    config.options.multiSubnetFailover = parsed.multisubnetfailover.toLowerCase() === 'true'\r\n  }\r\n\r\n  if (/^(.*)\\\\(.*)$/.exec(user)) {\r\n    config.domain = RegExp.$1\r\n    user = RegExp.$2\r\n  }\r\n\r\n  if (server) {\r\n    server = server.trim()\r\n\r\n    if (/^np:/i.test(server)) {\r\n      throw new Error('Connection via Named Pipes is not supported.')\r\n    }\r\n\r\n    if (/^tcp:/i.test(server)) {\r\n      server = server.substr(4)\r\n    }\r\n\r\n    if (/^(.*)\\\\(.*)$/.exec(server)) {\r\n      server = RegExp.$1\r\n      config.options.instanceName = RegExp.$2\r\n    }\r\n\r\n    if (/^(.*),(.*)$/.exec(server)) {\r\n      server = RegExp.$1.trim()\r\n      config.port = parseInt(RegExp.$2.trim(), 10)\r\n    }\r\n\r\n    if (server === '.' || server === '(.)' || server.toLowerCase() === '(localdb)' || server.toLowerCase() === '(local)') {\r\n      server = 'localhost'\r\n    }\r\n  }\r\n\r\n  config.user = user\r\n  config.server = server\r\n  return config\r\n}\r\n\r\nmodule.exports = {\r\n  parse: parseConnectionString,\r\n  resolve: resolveConnectionString\r\n}\r\n"]},"metadata":{},"sourceType":"script"}