{"ast":null,"code":"'use strict';\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst debug = require('debug')('mssql:base');\n\nconst tarn = require('tarn');\n\nconst {\n  IDS\n} = require('../utils');\n\nconst ConnectionString = require('../connectionstring');\n\nconst ConnectionError = require('../error/connection-error');\n\nconst shared = require('../shared');\n/**\r\n * Class ConnectionPool.\r\n *\r\n * Internally, each `Connection` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool.\r\n *\r\n * @property {Boolean} connected If true, connection is established.\r\n * @property {Boolean} connecting If true, connection is being established.\r\n *\r\n * @fires ConnectionPool#connect\r\n * @fires ConnectionPool#close\r\n */\n\n\nclass ConnectionPool extends EventEmitter {\n  /**\r\n   * Create new Connection.\r\n   *\r\n   * @param {Object|String} config Connection configuration object or connection string.\r\n   * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred.\r\n   */\n  constructor(config, callback) {\n    super();\n    IDS.add(this, 'ConnectionPool');\n    debug('pool(%d): created', IDS.get(this));\n    this._connectStack = [];\n    this._closeStack = [];\n    this._connected = false;\n    this._connecting = false;\n    this._healthy = false;\n\n    if (typeof config === 'string') {\n      try {\n        this.config = ConnectionString.resolve(config, shared.driver.name);\n      } catch (ex) {\n        if (typeof callback === 'function') {\n          return setImmediate(callback, ex);\n        }\n\n        throw ex;\n      }\n    } else {\n      this.config = Object.assign({}, config);\n    } // set defaults\n\n\n    this.config.port = this.config.port || 1433;\n    this.config.options = this.config.options || {};\n    this.config.stream = this.config.stream || false;\n    this.config.parseJSON = this.config.parseJSON || false;\n\n    if (/^(.*)\\\\(.*)$/.exec(this.config.server)) {\n      this.config.server = RegExp.$1;\n      this.config.options.instanceName = RegExp.$2;\n    }\n\n    if (typeof callback === 'function') {\n      this.connect(callback);\n    }\n  }\n\n  get connected() {\n    return this._connected;\n  }\n\n  get connecting() {\n    return this._connecting;\n  }\n\n  get healthy() {\n    return this._healthy;\n  }\n  /**\r\n   * Acquire connection from this connection pool.\r\n   *\r\n   * @param {ConnectionPool|Transaction|PreparedStatement} requester Requester.\r\n   * @param {acquireCallback} [callback] A callback which is called after connection has been acquired, or an error has occurred. If omited, method returns Promise.\r\n   * @return {ConnectionPool|Promise}\r\n   */\n\n\n  acquire(requester, callback) {\n    const acquirePromise = shared.Promise.resolve(this._acquire().promise).catch(err => {\n      this.emit('error', err);\n      throw err;\n    });\n\n    if (typeof callback === 'function') {\n      acquirePromise.then(connection => callback(null, connection, this.config)).catch(callback);\n      return this;\n    }\n\n    return acquirePromise;\n  }\n\n  _acquire() {\n    if (!this.pool) {\n      return shared.Promise.reject(new ConnectionError('Connection not yet open.', 'ENOTOPEN'));\n    } else if (this.pool.destroyed) {\n      return shared.Promise.reject(new ConnectionError('Connection is closing', 'ENOTOPEN'));\n    }\n\n    return this.pool.acquire();\n  }\n  /**\r\n   * Release connection back to the pool.\r\n   *\r\n   * @param {Connection} connection Previously acquired connection.\r\n   * @return {ConnectionPool}\r\n   */\n\n\n  release(connection) {\n    debug('connection(%d): released', IDS.get(connection));\n\n    if (this.pool) {\n      this.pool.release(connection);\n    }\n\n    return this;\n  }\n  /**\r\n   * Creates a new connection pool with one active connection. This one initial connection serves as a probe to find out whether the configuration is valid.\r\n   *\r\n   * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.\r\n   * @return {ConnectionPool|Promise}\r\n   */\n\n\n  connect(callback) {\n    if (typeof callback === 'function') {\n      this._connect(callback);\n\n      return this;\n    }\n\n    return new shared.Promise((resolve, reject) => {\n      return this._connect(err => {\n        if (err) return reject(err);\n        resolve(this);\n      });\n    });\n  }\n  /**\r\n   * @private\r\n   * @param {basicCallback} callback\r\n   */\n\n\n  _connect(callback) {\n    if (this._connected) {\n      debug('pool(%d): already connected, executing connect callback immediately', IDS.get(this));\n      return setImmediate(callback, null, this);\n    }\n\n    this._connectStack.push(callback);\n\n    if (this._connecting) {\n      return;\n    }\n\n    this._connecting = true;\n    debug('pool(%d): connecting', IDS.get(this)); // create one test connection to check if everything is ok\n\n    this._poolCreate().then(connection => {\n      debug('pool(%d): connected', IDS.get(this));\n      this._healthy = true;\n      return this._poolDestroy(connection).then(() => {\n        // prepare pool\n        this.pool = new tarn.Pool(Object.assign({\n          create: () => this._poolCreate().then(connection => {\n            this._healthy = true;\n            return connection;\n          }).catch(err => {\n            if (this.pool.numUsed() + this.pool.numFree() <= 0) {\n              this._healthy = false;\n            }\n\n            throw err;\n          }),\n          validate: this._poolValidate.bind(this),\n          destroy: this._poolDestroy.bind(this),\n          max: 10,\n          min: 0,\n          idleTimeoutMillis: 30000,\n          propagateCreateError: true\n        }, this.config.pool));\n        const self = this;\n        Object.defineProperties(this.pool, {\n          size: {\n            get: () => {\n              const message = 'the `size` property on pool is deprecated, access it directly on the `ConnectionPool`';\n              self.emit('debug', message);\n              process.emitWarning(message);\n              return self.size;\n            }\n          },\n          available: {\n            get: () => {\n              const message = 'the `available` property on pool is deprecated, access it directly on the `ConnectionPool`';\n              self.emit('debug', message);\n              process.emitWarning(message);\n              return self.available;\n            }\n          },\n          pending: {\n            get: () => {\n              const message = 'the `pending` property on pool is deprecate, access it directly on the `ConnectionPool`';\n              self.emit('debug', message);\n              process.emitWarning(message);\n              return self.pending;\n            }\n          },\n          borrowed: {\n            get: () => {\n              const message = 'the `borrowed` property on pool is deprecated, access it directly on the `ConnectionPool`';\n              self.emit('debug', message);\n              process.emitWarning(message);\n              return self.borrowed;\n            }\n          }\n        });\n        this._connecting = false;\n        this._connected = true;\n      });\n    }).then(() => {\n      this._connectStack.forEach(cb => {\n        setImmediate(cb, null, this);\n      });\n    }).catch(err => {\n      this._connecting = false;\n\n      this._connectStack.forEach(cb => {\n        setImmediate(cb, err);\n      });\n    }).then(() => {\n      this._connectStack = [];\n    });\n  }\n\n  get size() {\n    return this.pool.numFree() + this.pool.numUsed() + this.pool.numPendingCreates();\n  }\n\n  get available() {\n    return this.pool.numFree();\n  }\n\n  get pending() {\n    return this.pool.numPendingAcquires();\n  }\n\n  get borrowed() {\n    return this.pool.numUsed();\n  }\n  /**\r\n   * Close all active connections in the pool.\r\n   *\r\n   * @param {basicCallback} [callback] A callback which is called after connection has closed, or an error has occurred. If omited, method returns Promise.\r\n   * @return {ConnectionPool|Promise}\r\n   */\n\n\n  close(callback) {\n    if (typeof callback === 'function') {\n      this._close(callback);\n\n      return this;\n    }\n\n    return new shared.Promise((resolve, reject) => {\n      this._close(err => {\n        if (err) return reject(err);\n        resolve(this);\n      });\n    });\n  }\n  /**\r\n   * @private\r\n   * @param {basicCallback} callback\r\n   */\n\n\n  _close(callback) {\n    // we don't allow pools in a connecting state to be closed because it means there are far too many\n    // edge cases to deal with\n    if (this._connecting) {\n      debug('pool(%d): close called while connecting', IDS.get(this));\n      setImmediate(callback, new ConnectionError('Cannot close a pool while it is connecting'));\n    }\n\n    if (!this.pool) {\n      debug('pool(%d): already closed, executing close callback immediately', IDS.get(this));\n      return setImmediate(callback, null);\n    }\n\n    this._closeStack.push(callback);\n\n    if (this.pool.destroyed) return;\n    this._connecting = this._connected = this._healthy = false;\n    this.pool.destroy().then(() => {\n      debug('pool(%d): pool closed, removing pool reference and executing close callbacks', IDS.get(this));\n      this.pool = null;\n\n      this._closeStack.forEach(cb => {\n        setImmediate(cb, null);\n      });\n    }).catch(err => {\n      this.pool = null;\n\n      this._closeStack.forEach(cb => {\n        setImmediate(cb, err);\n      });\n    }).then(() => {\n      this._closeStack = [];\n    });\n  }\n  /**\r\n   * Returns new request using this connection.\r\n   *\r\n   * @return {Request}\r\n   */\n\n\n  request() {\n    return new shared.driver.Request(this);\n  }\n  /**\r\n   * Returns new transaction using this connection.\r\n   *\r\n   * @return {Transaction}\r\n   */\n\n\n  transaction() {\n    return new shared.driver.Transaction(this);\n  }\n  /**\r\n   * Creates a new query using this connection from a tagged template string.\r\n   *\r\n   * @variation 1\r\n   * @param {Array} strings Array of string literals.\r\n   * @param {...*} keys Values.\r\n   * @return {Request}\r\n   */\n\n  /**\r\n   * Execute the SQL command.\r\n   *\r\n   * @variation 2\r\n   * @param {String} command T-SQL command to be executed.\r\n   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\r\n   * @return {Request|Promise}\r\n   */\n\n\n  query() {\n    if (typeof arguments[0] === 'string') {\n      return new shared.driver.Request(this).query(arguments[0], arguments[1]);\n    }\n\n    const values = Array.prototype.slice.call(arguments);\n    const strings = values.shift();\n    return new shared.driver.Request(this)._template(strings, values, 'query');\n  }\n  /**\r\n   * Creates a new batch using this connection from a tagged template string.\r\n   *\r\n   * @variation 1\r\n   * @param {Array} strings Array of string literals.\r\n   * @param {...*} keys Values.\r\n   * @return {Request}\r\n   */\n\n  /**\r\n   * Execute the SQL command.\r\n   *\r\n   * @variation 2\r\n   * @param {String} command T-SQL command to be executed.\r\n   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\r\n   * @return {Request|Promise}\r\n   */\n\n\n  batch() {\n    if (typeof arguments[0] === 'string') {\n      return new shared.driver.Request(this).batch(arguments[0], arguments[1]);\n    }\n\n    const values = Array.prototype.slice.call(arguments);\n    const strings = values.shift();\n    return new shared.driver.Request(this)._template(strings, values, 'batch');\n  }\n\n}\n\nmodule.exports = ConnectionPool;","map":{"version":3,"sources":["C:/Projects/sqlsample/node_modules/mssql/lib/base/connection-pool.js"],"names":["EventEmitter","require","debug","tarn","IDS","ConnectionString","ConnectionError","shared","ConnectionPool","constructor","config","callback","add","get","_connectStack","_closeStack","_connected","_connecting","_healthy","resolve","driver","name","ex","setImmediate","Object","assign","port","options","stream","parseJSON","exec","server","RegExp","$1","instanceName","$2","connect","connected","connecting","healthy","acquire","requester","acquirePromise","Promise","_acquire","promise","catch","err","emit","then","connection","pool","reject","destroyed","release","_connect","push","_poolCreate","_poolDestroy","Pool","create","numUsed","numFree","validate","_poolValidate","bind","destroy","max","min","idleTimeoutMillis","propagateCreateError","self","defineProperties","size","message","process","emitWarning","available","pending","borrowed","forEach","cb","numPendingCreates","numPendingAcquires","close","_close","request","Request","transaction","Transaction","query","arguments","values","Array","prototype","slice","call","strings","shift","_template","batch","module","exports"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst { EventEmitter } = require('events')\r\nconst debug = require('debug')('mssql:base')\r\nconst tarn = require('tarn')\r\nconst { IDS } = require('../utils')\r\nconst ConnectionString = require('../connectionstring')\r\nconst ConnectionError = require('../error/connection-error')\r\nconst shared = require('../shared')\r\n\r\n/**\r\n * Class ConnectionPool.\r\n *\r\n * Internally, each `Connection` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool.\r\n *\r\n * @property {Boolean} connected If true, connection is established.\r\n * @property {Boolean} connecting If true, connection is being established.\r\n *\r\n * @fires ConnectionPool#connect\r\n * @fires ConnectionPool#close\r\n */\r\n\r\nclass ConnectionPool extends EventEmitter {\r\n  /**\r\n   * Create new Connection.\r\n   *\r\n   * @param {Object|String} config Connection configuration object or connection string.\r\n   * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred.\r\n   */\r\n\r\n  constructor (config, callback) {\r\n    super()\r\n\r\n    IDS.add(this, 'ConnectionPool')\r\n    debug('pool(%d): created', IDS.get(this))\r\n\r\n    this._connectStack = []\r\n    this._closeStack = []\r\n\r\n    this._connected = false\r\n    this._connecting = false\r\n    this._healthy = false\r\n\r\n    if (typeof config === 'string') {\r\n      try {\r\n        this.config = ConnectionString.resolve(config, shared.driver.name)\r\n      } catch (ex) {\r\n        if (typeof callback === 'function') {\r\n          return setImmediate(callback, ex)\r\n        }\r\n        throw ex\r\n      }\r\n    } else {\r\n      this.config = Object.assign({}, config)\r\n    }\r\n\r\n    // set defaults\r\n    this.config.port = this.config.port || 1433\r\n    this.config.options = this.config.options || {}\r\n    this.config.stream = this.config.stream || false\r\n    this.config.parseJSON = this.config.parseJSON || false\r\n\r\n    if (/^(.*)\\\\(.*)$/.exec(this.config.server)) {\r\n      this.config.server = RegExp.$1\r\n      this.config.options.instanceName = RegExp.$2\r\n    }\r\n\r\n    if (typeof callback === 'function') {\r\n      this.connect(callback)\r\n    }\r\n  }\r\n\r\n  get connected () {\r\n    return this._connected\r\n  }\r\n\r\n  get connecting () {\r\n    return this._connecting\r\n  }\r\n\r\n  get healthy () {\r\n    return this._healthy\r\n  }\r\n\r\n  /**\r\n   * Acquire connection from this connection pool.\r\n   *\r\n   * @param {ConnectionPool|Transaction|PreparedStatement} requester Requester.\r\n   * @param {acquireCallback} [callback] A callback which is called after connection has been acquired, or an error has occurred. If omited, method returns Promise.\r\n   * @return {ConnectionPool|Promise}\r\n   */\r\n\r\n  acquire (requester, callback) {\r\n    const acquirePromise = shared.Promise.resolve(this._acquire().promise).catch(err => {\r\n      this.emit('error', err)\r\n      throw err\r\n    })\r\n    if (typeof callback === 'function') {\r\n      acquirePromise.then(connection => callback(null, connection, this.config)).catch(callback)\r\n      return this\r\n    }\r\n\r\n    return acquirePromise\r\n  }\r\n\r\n  _acquire () {\r\n    if (!this.pool) {\r\n      return shared.Promise.reject(new ConnectionError('Connection not yet open.', 'ENOTOPEN'))\r\n    } else if (this.pool.destroyed) {\r\n      return shared.Promise.reject(new ConnectionError('Connection is closing', 'ENOTOPEN'))\r\n    }\r\n\r\n    return this.pool.acquire()\r\n  }\r\n\r\n  /**\r\n   * Release connection back to the pool.\r\n   *\r\n   * @param {Connection} connection Previously acquired connection.\r\n   * @return {ConnectionPool}\r\n   */\r\n\r\n  release (connection) {\r\n    debug('connection(%d): released', IDS.get(connection))\r\n\r\n    if (this.pool) {\r\n      this.pool.release(connection)\r\n    }\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Creates a new connection pool with one active connection. This one initial connection serves as a probe to find out whether the configuration is valid.\r\n   *\r\n   * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.\r\n   * @return {ConnectionPool|Promise}\r\n   */\r\n\r\n  connect (callback) {\r\n    if (typeof callback === 'function') {\r\n      this._connect(callback)\r\n      return this\r\n    }\r\n\r\n    return new shared.Promise((resolve, reject) => {\r\n      return this._connect(err => {\r\n        if (err) return reject(err)\r\n        resolve(this)\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {basicCallback} callback\r\n   */\r\n\r\n  _connect (callback) {\r\n    if (this._connected) {\r\n      debug('pool(%d): already connected, executing connect callback immediately', IDS.get(this))\r\n      return setImmediate(callback, null, this)\r\n    }\r\n\r\n    this._connectStack.push(callback)\r\n\r\n    if (this._connecting) {\r\n      return\r\n    }\r\n\r\n    this._connecting = true\r\n    debug('pool(%d): connecting', IDS.get(this))\r\n\r\n    // create one test connection to check if everything is ok\r\n    this._poolCreate().then((connection) => {\r\n      debug('pool(%d): connected', IDS.get(this))\r\n      this._healthy = true\r\n\r\n      return this._poolDestroy(connection).then(() => {\r\n        // prepare pool\r\n        this.pool = new tarn.Pool(\r\n          Object.assign({\r\n            create: () => this._poolCreate()\r\n              .then(connection => {\r\n                this._healthy = true\r\n                return connection\r\n              })\r\n              .catch(err => {\r\n                if (this.pool.numUsed() + this.pool.numFree() <= 0) {\r\n                  this._healthy = false\r\n                }\r\n                throw err\r\n              }),\r\n            validate: this._poolValidate.bind(this),\r\n            destroy: this._poolDestroy.bind(this),\r\n            max: 10,\r\n            min: 0,\r\n            idleTimeoutMillis: 30000,\r\n            propagateCreateError: true\r\n          }, this.config.pool)\r\n        )\r\n        const self = this\r\n        Object.defineProperties(this.pool, {\r\n          size: {\r\n            get: () => {\r\n              const message = 'the `size` property on pool is deprecated, access it directly on the `ConnectionPool`'\r\n              self.emit('debug', message)\r\n              process.emitWarning(message)\r\n              return self.size\r\n            }\r\n          },\r\n          available: {\r\n            get: () => {\r\n              const message = 'the `available` property on pool is deprecated, access it directly on the `ConnectionPool`'\r\n              self.emit('debug', message)\r\n              process.emitWarning(message)\r\n              return self.available\r\n            }\r\n          },\r\n          pending: {\r\n            get: () => {\r\n              const message = 'the `pending` property on pool is deprecate, access it directly on the `ConnectionPool`'\r\n              self.emit('debug', message)\r\n              process.emitWarning(message)\r\n              return self.pending\r\n            }\r\n          },\r\n          borrowed: {\r\n            get: () => {\r\n              const message = 'the `borrowed` property on pool is deprecated, access it directly on the `ConnectionPool`'\r\n              self.emit('debug', message)\r\n              process.emitWarning(message)\r\n              return self.borrowed\r\n            }\r\n          }\r\n        })\r\n\r\n        this._connecting = false\r\n        this._connected = true\r\n      })\r\n    }).then(() => {\r\n      this._connectStack.forEach((cb) => {\r\n        setImmediate(cb, null, this)\r\n      })\r\n    }).catch(err => {\r\n      this._connecting = false\r\n      this._connectStack.forEach((cb) => {\r\n        setImmediate(cb, err)\r\n      })\r\n    }).then(() => {\r\n      this._connectStack = []\r\n    })\r\n  }\r\n\r\n  get size () {\r\n    return this.pool.numFree() + this.pool.numUsed() + this.pool.numPendingCreates()\r\n  }\r\n\r\n  get available () {\r\n    return this.pool.numFree()\r\n  }\r\n\r\n  get pending () {\r\n    return this.pool.numPendingAcquires()\r\n  }\r\n\r\n  get borrowed () {\r\n    return this.pool.numUsed()\r\n  }\r\n\r\n  /**\r\n   * Close all active connections in the pool.\r\n   *\r\n   * @param {basicCallback} [callback] A callback which is called after connection has closed, or an error has occurred. If omited, method returns Promise.\r\n   * @return {ConnectionPool|Promise}\r\n   */\r\n\r\n  close (callback) {\r\n    if (typeof callback === 'function') {\r\n      this._close(callback)\r\n      return this\r\n    }\r\n\r\n    return new shared.Promise((resolve, reject) => {\r\n      this._close(err => {\r\n        if (err) return reject(err)\r\n        resolve(this)\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {basicCallback} callback\r\n   */\r\n\r\n  _close (callback) {\r\n    // we don't allow pools in a connecting state to be closed because it means there are far too many\r\n    // edge cases to deal with\r\n    if (this._connecting) {\r\n      debug('pool(%d): close called while connecting', IDS.get(this))\r\n      setImmediate(callback, new ConnectionError('Cannot close a pool while it is connecting'))\r\n    }\r\n\r\n    if (!this.pool) {\r\n      debug('pool(%d): already closed, executing close callback immediately', IDS.get(this))\r\n      return setImmediate(callback, null)\r\n    }\r\n\r\n    this._closeStack.push(callback)\r\n\r\n    if (this.pool.destroyed) return\r\n\r\n    this._connecting = this._connected = this._healthy = false\r\n\r\n    this.pool.destroy().then(() => {\r\n      debug('pool(%d): pool closed, removing pool reference and executing close callbacks', IDS.get(this))\r\n      this.pool = null\r\n      this._closeStack.forEach(cb => {\r\n        setImmediate(cb, null)\r\n      })\r\n    }).catch(err => {\r\n      this.pool = null\r\n      this._closeStack.forEach(cb => {\r\n        setImmediate(cb, err)\r\n      })\r\n    }).then(() => {\r\n      this._closeStack = []\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns new request using this connection.\r\n   *\r\n   * @return {Request}\r\n   */\r\n\r\n  request () {\r\n    return new shared.driver.Request(this)\r\n  }\r\n\r\n  /**\r\n   * Returns new transaction using this connection.\r\n   *\r\n   * @return {Transaction}\r\n   */\r\n\r\n  transaction () {\r\n    return new shared.driver.Transaction(this)\r\n  }\r\n\r\n  /**\r\n   * Creates a new query using this connection from a tagged template string.\r\n   *\r\n   * @variation 1\r\n   * @param {Array} strings Array of string literals.\r\n   * @param {...*} keys Values.\r\n   * @return {Request}\r\n   */\r\n\r\n  /**\r\n   * Execute the SQL command.\r\n   *\r\n   * @variation 2\r\n   * @param {String} command T-SQL command to be executed.\r\n   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\r\n   * @return {Request|Promise}\r\n   */\r\n\r\n  query () {\r\n    if (typeof arguments[0] === 'string') { return new shared.driver.Request(this).query(arguments[0], arguments[1]) }\r\n\r\n    const values = Array.prototype.slice.call(arguments)\r\n    const strings = values.shift()\r\n\r\n    return new shared.driver.Request(this)._template(strings, values, 'query')\r\n  }\r\n\r\n  /**\r\n   * Creates a new batch using this connection from a tagged template string.\r\n   *\r\n   * @variation 1\r\n   * @param {Array} strings Array of string literals.\r\n   * @param {...*} keys Values.\r\n   * @return {Request}\r\n   */\r\n\r\n  /**\r\n   * Execute the SQL command.\r\n   *\r\n   * @variation 2\r\n   * @param {String} command T-SQL command to be executed.\r\n   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\r\n   * @return {Request|Promise}\r\n   */\r\n\r\n  batch () {\r\n    if (typeof arguments[0] === 'string') { return new shared.driver.Request(this).batch(arguments[0], arguments[1]) }\r\n\r\n    const values = Array.prototype.slice.call(arguments)\r\n    const strings = values.shift()\r\n\r\n    return new shared.driver.Request(this)._template(strings, values, 'batch')\r\n  }\r\n}\r\n\r\nmodule.exports = ConnectionPool\r\n"]},"metadata":{},"sourceType":"script"}