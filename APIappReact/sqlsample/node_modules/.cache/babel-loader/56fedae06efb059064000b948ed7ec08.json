{"ast":null,"code":"'use strict';\n\nconst tds = require('tedious');\n\nconst debug = require('debug')('mssql:tedi');\n\nconst BaseRequest = require('../base/request');\n\nconst RequestError = require('../error/request-error');\n\nconst {\n  IDS,\n  objectHasProperty\n} = require('../utils');\n\nconst {\n  TYPES,\n  DECLARATIONS,\n  declare,\n  cast\n} = require('../datatypes');\n\nconst Table = require('../table');\n\nconst {\n  PARSERS: UDT\n} = require('../udt');\n\nconst JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B';\nconst XML_COLUMN_ID = 'XML_F52E2B61-18A1-11d1-B105-00805F49916B';\nconst N_TYPES = {\n  BitN: 0x68,\n  DateTimeN: 0x6F,\n  DecimalN: 0x6A,\n  FloatN: 0x6D,\n  IntN: 0x26,\n  MoneyN: 0x6E,\n  NumericN: 0x6C\n};\n\nconst getTediousType = function (type) {\n  switch (type) {\n    case TYPES.VarChar:\n      return tds.TYPES.VarChar;\n\n    case TYPES.NVarChar:\n      return tds.TYPES.NVarChar;\n\n    case TYPES.Text:\n      return tds.TYPES.Text;\n\n    case TYPES.Int:\n      return tds.TYPES.Int;\n\n    case TYPES.BigInt:\n      return tds.TYPES.BigInt;\n\n    case TYPES.TinyInt:\n      return tds.TYPES.TinyInt;\n\n    case TYPES.SmallInt:\n      return tds.TYPES.SmallInt;\n\n    case TYPES.Bit:\n      return tds.TYPES.Bit;\n\n    case TYPES.Float:\n      return tds.TYPES.Float;\n\n    case TYPES.Decimal:\n      return tds.TYPES.Decimal;\n\n    case TYPES.Numeric:\n      return tds.TYPES.Numeric;\n\n    case TYPES.Real:\n      return tds.TYPES.Real;\n\n    case TYPES.Money:\n      return tds.TYPES.Money;\n\n    case TYPES.SmallMoney:\n      return tds.TYPES.SmallMoney;\n\n    case TYPES.Time:\n      return tds.TYPES.Time;\n\n    case TYPES.Date:\n      return tds.TYPES.Date;\n\n    case TYPES.DateTime:\n      return tds.TYPES.DateTime;\n\n    case TYPES.DateTime2:\n      return tds.TYPES.DateTime2;\n\n    case TYPES.DateTimeOffset:\n      return tds.TYPES.DateTimeOffset;\n\n    case TYPES.SmallDateTime:\n      return tds.TYPES.SmallDateTime;\n\n    case TYPES.UniqueIdentifier:\n      return tds.TYPES.UniqueIdentifier;\n\n    case TYPES.Xml:\n      return tds.TYPES.NVarChar;\n\n    case TYPES.Char:\n      return tds.TYPES.Char;\n\n    case TYPES.NChar:\n      return tds.TYPES.NChar;\n\n    case TYPES.NText:\n      return tds.TYPES.NVarChar;\n\n    case TYPES.Image:\n      return tds.TYPES.Image;\n\n    case TYPES.Binary:\n      return tds.TYPES.Binary;\n\n    case TYPES.VarBinary:\n      return tds.TYPES.VarBinary;\n\n    case TYPES.UDT:\n    case TYPES.Geography:\n    case TYPES.Geometry:\n      return tds.TYPES.UDT;\n\n    case TYPES.TVP:\n      return tds.TYPES.TVP;\n\n    case TYPES.Variant:\n      return tds.TYPES.Variant;\n\n    default:\n      return type;\n  }\n};\n\nconst getMssqlType = function (type, length) {\n  if (typeof type !== 'object') return undefined;\n\n  switch (type) {\n    case tds.TYPES.Char:\n      return TYPES.Char;\n\n    case tds.TYPES.NChar:\n      return TYPES.NChar;\n\n    case tds.TYPES.VarChar:\n      return TYPES.VarChar;\n\n    case tds.TYPES.NVarChar:\n      return TYPES.NVarChar;\n\n    case tds.TYPES.Text:\n      return TYPES.Text;\n\n    case tds.TYPES.NText:\n      return TYPES.NText;\n\n    case tds.TYPES.Int:\n      return TYPES.Int;\n\n    case tds.TYPES.BigInt:\n      return TYPES.BigInt;\n\n    case tds.TYPES.TinyInt:\n      return TYPES.TinyInt;\n\n    case tds.TYPES.SmallInt:\n      return TYPES.SmallInt;\n\n    case tds.TYPES.Bit:\n      return TYPES.Bit;\n\n    case tds.TYPES.Float:\n      return TYPES.Float;\n\n    case tds.TYPES.Real:\n      return TYPES.Real;\n\n    case tds.TYPES.Money:\n      return TYPES.Money;\n\n    case tds.TYPES.SmallMoney:\n      return TYPES.SmallMoney;\n\n    case tds.TYPES.Numeric:\n      return TYPES.Numeric;\n\n    case tds.TYPES.Decimal:\n      return TYPES.Decimal;\n\n    case tds.TYPES.DateTime:\n      return TYPES.DateTime;\n\n    case tds.TYPES.Time:\n      return TYPES.Time;\n\n    case tds.TYPES.Date:\n      return TYPES.Date;\n\n    case tds.TYPES.DateTime2:\n      return TYPES.DateTime2;\n\n    case tds.TYPES.DateTimeOffset:\n      return TYPES.DateTimeOffset;\n\n    case tds.TYPES.SmallDateTime:\n      return TYPES.SmallDateTime;\n\n    case tds.TYPES.UniqueIdentifier:\n      return TYPES.UniqueIdentifier;\n\n    case tds.TYPES.Image:\n      return TYPES.Image;\n\n    case tds.TYPES.Binary:\n      return TYPES.Binary;\n\n    case tds.TYPES.VarBinary:\n      return TYPES.VarBinary;\n\n    case tds.TYPES.Xml:\n      return TYPES.Xml;\n\n    case tds.TYPES.UDT:\n      return TYPES.UDT;\n\n    case tds.TYPES.TVP:\n      return TYPES.TVP;\n\n    case tds.TYPES.Variant:\n      return TYPES.Variant;\n\n    default:\n      switch (type.id) {\n        case N_TYPES.BitN:\n          return TYPES.Bit;\n\n        case N_TYPES.NumericN:\n          return TYPES.Numeric;\n\n        case N_TYPES.DecimalN:\n          return TYPES.Decimal;\n\n        case N_TYPES.IntN:\n          if (length === 8) return TYPES.BigInt;\n          if (length === 4) return TYPES.Int;\n          if (length === 2) return TYPES.SmallInt;\n          return TYPES.TinyInt;\n\n        case N_TYPES.FloatN:\n          if (length === 8) return TYPES.Float;\n          return TYPES.Real;\n\n        case N_TYPES.MoneyN:\n          if (length === 8) return TYPES.Money;\n          return TYPES.SmallMoney;\n\n        case N_TYPES.DateTimeN:\n          if (length === 8) return TYPES.DateTime;\n          return TYPES.SmallDateTime;\n      }\n\n  }\n};\n\nconst createColumns = function (metadata) {\n  const out = {};\n\n  for (let index = 0, length = metadata.length; index < length; index++) {\n    const column = metadata[index];\n    out[column.colName] = {\n      index,\n      name: column.colName,\n      length: column.dataLength,\n      type: getMssqlType(column.type, column.dataLength),\n      scale: column.scale,\n      precision: column.precision,\n      nullable: !!(column.flags & 0x01),\n      caseSensitive: !!(column.flags & 0x02),\n      identity: !!(column.flags & 0x10),\n      readOnly: !(column.flags & 0x0C)\n    };\n\n    if (column.udtInfo) {\n      out[column.colName].udt = {\n        name: column.udtInfo.typeName,\n        database: column.udtInfo.dbname,\n        schema: column.udtInfo.owningSchema,\n        assembly: column.udtInfo.assemblyName\n      };\n\n      if (DECLARATIONS[column.udtInfo.typeName]) {\n        out[column.colName].type = DECLARATIONS[column.udtInfo.typeName];\n      }\n    }\n  }\n\n  return out;\n};\n\nconst valueCorrection = function (value, metadata) {\n  if (metadata.type === tds.TYPES.UDT && value != null) {\n    if (UDT[metadata.udtInfo.typeName]) {\n      return UDT[metadata.udtInfo.typeName](value);\n    } else {\n      return value;\n    }\n  } else {\n    return value;\n  }\n};\n\nconst parameterCorrection = function (value) {\n  if (value instanceof Table) {\n    const tvp = {\n      name: value.name,\n      schema: value.schema,\n      columns: [],\n      rows: value.rows\n    };\n\n    for (const col of value.columns) {\n      tvp.columns.push({\n        name: col.name,\n        type: getTediousType(col.type),\n        length: col.length,\n        scale: col.scale,\n        precision: col.precision\n      });\n    }\n\n    return tvp;\n  } else {\n    return value;\n  }\n};\n\nclass Request extends BaseRequest {\n  /*\r\n  Execute specified sql batch.\r\n  */\n  _batch(batch, callback) {\n    this._isBatch = true;\n\n    this._query(batch, callback);\n  }\n  /*\r\n  Bulk load.\r\n  */\n\n\n  _bulk(table, options, callback) {\n    super._bulk(table, options, err => {\n      if (err) return callback(err);\n\n      table._makeBulk();\n\n      if (!table.name) {\n        return callback(new RequestError('Table name must be specified for bulk insert.', 'ENAME'));\n      }\n\n      if (table.name.charAt(0) === '@') {\n        return callback(new RequestError(\"You can't use table variables for bulk insert.\", 'ENAME'));\n      }\n\n      const errors = [];\n      const errorHandlers = {};\n      let hasReturned = false;\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message);\n        err.info = info;\n        err = new RequestError(err, 'EREQUEST');\n\n        if (this.stream) {\n          this.emit('error', err);\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n\n              this.parent.release(connection);\n            }\n\n            hasReturned = true;\n            callback(err);\n          }\n        } // we must collect errors even in stream mode\n\n\n        errors.push(err);\n      };\n\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        });\n      };\n\n      this.parent.acquire(this, (err, connection) => {\n        if (err) return callback(err);\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this));\n\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this));\n          this.parent.release(connection);\n          return callback(new RequestError('Canceled.', 'ECANCEL'));\n        }\n\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this));\n          connection.cancel();\n        }; // attach handler to handle multiple error messages\n\n\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n\n        const done = (err, rowCount) => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n            err = new RequestError(err, 'EREQUEST');\n            if (this.stream) this.emit('error', err);\n            errors.push(err);\n          }\n\n          delete this._cancel;\n          let error;\n\n          if (errors.length && !this.stream) {\n            error = errors.pop();\n            error.precedingErrors = errors;\n          }\n\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event]);\n            }\n\n            this.parent.release(connection);\n            hasReturned = true;\n\n            if (this.stream) {\n              callback(null, rowCount);\n            } else {\n              callback(error, rowCount);\n            }\n          }\n        };\n\n        const bulk = connection.newBulkLoad(table.path, options, done);\n\n        for (const col of table.columns) {\n          bulk.addColumn(col.name, getTediousType(col.type), {\n            nullable: col.nullable,\n            length: col.length,\n            scale: col.scale,\n            precision: col.precision\n          });\n        }\n\n        for (const row of table.rows) {\n          bulk.addRow(row);\n        }\n\n        if (table.create) {\n          const objectid = table.temporary ? `tempdb..[${table.name}]` : table.path;\n          const req = new tds.Request(`if object_id('${objectid.replace(/'/g, '\\'\\'')}') is null ${table.declare()}`, err => {\n            if (err) return done(err);\n            connection.execBulkLoad(bulk);\n          });\n\n          this._setCurrentRequest(req);\n\n          connection.execSqlBatch(req);\n        } else {\n          connection.execBulkLoad(bulk);\n        }\n      });\n    });\n  }\n  /*\r\n  Execute specified sql command.\r\n  */\n\n\n  _query(command, callback) {\n    super._query(command, err => {\n      if (err) return callback(err);\n      const recordsets = [];\n      const errors = [];\n      const errorHandlers = {};\n      const output = {};\n      const rowsAffected = [];\n      let columns = {};\n      let recordset = [];\n      let batchLastRow = null;\n      let batchHasOutput = false;\n      let isChunkedRecordset = false;\n      let chunksBuffer = null;\n      let hasReturned = false;\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message);\n        err.info = info;\n        err = new RequestError(err, 'EREQUEST');\n\n        if (this.stream) {\n          this.emit('error', err);\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n\n              this.parent.release(connection);\n            }\n\n            hasReturned = true;\n            callback(err);\n          }\n        } // we must collect errors even in stream mode\n\n\n        errors.push(err);\n      };\n\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        });\n      };\n\n      this.parent.acquire(this, (err, connection, config) => {\n        if (err) return callback(err);\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this));\n        let row;\n\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this));\n          this.parent.release(connection);\n          return callback(new RequestError('Canceled.', 'ECANCEL'));\n        }\n\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this));\n          connection.cancel();\n        }; // attach handler to handle multiple error messages\n\n\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n        debug('request(%d): query', IDS.get(this), command);\n        const req = new tds.Request(command, err => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n            err = new RequestError(err, 'EREQUEST');\n            if (this.stream) this.emit('error', err);\n            errors.push(err);\n          } // process batch outputs\n\n\n          if (batchHasOutput) {\n            if (!this.stream) batchLastRow = recordsets.pop()[0];\n\n            for (const name in batchLastRow) {\n              const value = batchLastRow[name];\n\n              if (name !== '___return___') {\n                output[name] = value;\n              }\n            }\n          }\n\n          delete this._cancel;\n          let error;\n\n          if (errors.length && !this.stream) {\n            error = errors.pop();\n            error.precedingErrors = errors;\n          }\n\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event]);\n            }\n\n            this.parent.release(connection);\n            hasReturned = true;\n\n            if (error) {\n              debug('request(%d): failed', IDS.get(this), error);\n            } else {\n              debug('request(%d): completed', IDS.get(this));\n            }\n\n            if (this.stream) {\n              callback(null, null, output, rowsAffected);\n            } else {\n              callback(error, recordsets, output, rowsAffected);\n            }\n          }\n        });\n\n        this._setCurrentRequest(req);\n\n        req.on('columnMetadata', metadata => {\n          columns = createColumns(metadata);\n          isChunkedRecordset = false;\n\n          if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n            isChunkedRecordset = true;\n            chunksBuffer = [];\n          }\n\n          if (this.stream) {\n            if (this._isBatch) {\n              // don't stream recordset with output values in batches\n              if (!columns.___return___) {\n                this.emit('recordset', columns);\n              }\n            } else {\n              this.emit('recordset', columns);\n            }\n          }\n        });\n\n        const doneHandler = (rowCount, more) => {\n          if (rowCount != null) rowsAffected.push(rowCount); // this function is called even when select only set variables so we should skip adding a new recordset\n\n          if (Object.keys(columns).length === 0) return;\n\n          if (isChunkedRecordset) {\n            const concatenatedChunks = chunksBuffer.join('');\n\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n              try {\n                if (concatenatedChunks === '') {\n                  row = null;\n                } else {\n                  row = JSON.parse(concatenatedChunks);\n                }\n              } catch (ex) {\n                row = null;\n                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON');\n                if (this.stream) this.emit('error', ex2); // we must collect errors even in stream mode\n\n                errors.push(ex2);\n              }\n            } else {\n              row = {};\n              row[Object.keys(columns)[0]] = concatenatedChunks;\n            }\n\n            chunksBuffer = null;\n\n            if (this.stream) {\n              this.emit('row', row);\n            } else {\n              recordset.push(row);\n            }\n          }\n\n          if (!this.stream) {\n            // all rows of current recordset loaded\n            Object.defineProperty(recordset, 'columns', {\n              enumerable: false,\n              configurable: true,\n              value: columns\n            });\n            Object.defineProperty(recordset, 'toTable', {\n              enumerable: false,\n              configurable: true,\n\n              value(name) {\n                return Table.fromRecordset(this, name);\n              }\n\n            });\n            recordsets.push(recordset);\n          }\n\n          recordset = [];\n          columns = {};\n        };\n\n        req.on('doneInProc', doneHandler); // doneInProc handlers are used in both queries and batches\n\n        req.on('done', doneHandler); // done handlers are used in batches\n\n        req.on('returnValue', (parameterName, value, metadata) => {\n          output[parameterName] = value;\n        });\n        req.on('row', columns => {\n          if (!recordset) recordset = [];\n\n          if (isChunkedRecordset) {\n            return chunksBuffer.push(columns[0].value);\n          }\n\n          row = {};\n\n          for (const col of columns) {\n            col.value = valueCorrection(col.value, col.metadata);\n            const exi = row[col.metadata.colName];\n\n            if (exi != null) {\n              if (exi instanceof Array) {\n                exi.push(col.value);\n              } else {\n                row[col.metadata.colName] = [exi, col.value];\n              }\n            } else {\n              row[col.metadata.colName] = col.value;\n            }\n          }\n\n          if (this.stream) {\n            if (this._isBatch) {\n              // dont stream recordset with output values in batches\n              if (row.___return___) {\n                batchLastRow = row;\n              } else {\n                this.emit('row', row);\n              }\n            } else {\n              this.emit('row', row);\n            }\n          } else {\n            recordset.push(row);\n          }\n        });\n\n        if (this._isBatch) {\n          if (Object.keys(this.parameters).length) {\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue;\n              }\n\n              const param = this.parameters[name];\n              let value = getTediousType(param.type).validate(param.value);\n\n              if (value instanceof TypeError) {\n                value = new RequestError(`Validation failed for parameter '${name}'. ${value.message}`, 'EPARAM');\n                this.parent.release(connection);\n                return callback(value);\n              }\n\n              param.value = value;\n            }\n\n            const declarations = [];\n\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue;\n              }\n\n              const param = this.parameters[name];\n              declarations.push(`@${name} ${declare(param.type, param)}`);\n            }\n\n            const assigns = [];\n\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue;\n              }\n\n              const param = this.parameters[name];\n              assigns.push(`@${name} = ${cast(param.value, param.type, param)}`);\n            }\n\n            const selects = [];\n\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue;\n              }\n\n              const param = this.parameters[name];\n\n              if (param.io === 2) {\n                selects.push(`@${name} as [${name}]`);\n              }\n            }\n\n            batchHasOutput = selects.length > 0;\n            req.sqlTextOrProcedure = `declare ${declarations.join(', ')};select ${assigns.join(', ')};${req.sqlTextOrProcedure};${batchHasOutput ? `select 1 as [___return___], ${selects.join(', ')}` : ''}`;\n          }\n        } else {\n          for (const name in this.parameters) {\n            if (!objectHasProperty(this.parameters, name)) {\n              continue;\n            }\n\n            const param = this.parameters[name];\n\n            if (param.io === 1) {\n              req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n                length: param.length,\n                scale: param.scale,\n                precision: param.precision\n              });\n            } else {\n              req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n                length: param.length,\n                scale: param.scale,\n                precision: param.precision\n              });\n            }\n          }\n        }\n\n        try {\n          connection[this._isBatch ? 'execSqlBatch' : 'execSql'](req);\n        } catch (error) {\n          handleError(true, connection, error);\n        }\n      });\n    });\n  }\n  /*\r\n  Execute stored procedure with specified parameters.\r\n  */\n\n\n  _execute(procedure, callback) {\n    super._execute(procedure, err => {\n      if (err) return callback(err);\n      const recordsets = [];\n      const errors = [];\n      const errorHandlers = {};\n      const output = {};\n      const rowsAffected = [];\n      let columns = {};\n      let recordset = [];\n      let returnValue = 0;\n      let isChunkedRecordset = false;\n      let chunksBuffer = null;\n      let hasReturned = false;\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message);\n        err.info = info;\n        err = new RequestError(err, 'EREQUEST');\n\n        if (this.stream) {\n          this.emit('error', err);\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n\n              this.parent.release(connection);\n            }\n\n            hasReturned = true;\n            callback(err);\n          }\n        } // we must collect errors even in stream mode\n\n\n        errors.push(err);\n      };\n\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        });\n      };\n\n      this.parent.acquire(this, (err, connection, config) => {\n        if (err) return callback(err);\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this));\n        let row;\n\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this));\n          this.parent.release(connection);\n          return callback(new RequestError('Canceled.', 'ECANCEL'));\n        }\n\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this));\n          connection.cancel();\n        }; // attach handler to handle multiple error messages\n\n\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n\n        if (debug.enabled) {\n          // log stored procedure executions and provided parameters\n          const params = Object.keys(this.parameters).map(k => this.parameters[k]); // cut long string parameters short to keep log somewhat clean\n\n          const logValue = s => typeof s === 'string' && s.length > 50 ? s.substring(0, 47) + '...' : s; // format parameter names as 'my_parameter [sql.Int]'\n\n\n          const logName = param => param.name + ' [sql.' + param.type.name + ']';\n\n          const logParams = {};\n          params.forEach(p => {\n            logParams[logName(p)] = logValue(p.value);\n          });\n          debug('request(%d): execute %s %O', IDS.get(this), procedure, logParams);\n        }\n\n        const req = new tds.Request(procedure, err => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n            err = new RequestError(err, 'EREQUEST');\n            if (this.stream) this.emit('error', err);\n            errors.push(err);\n          }\n\n          delete this._cancel;\n          let error;\n\n          if (errors.length && !this.stream) {\n            error = errors.pop();\n            error.precedingErrors = errors;\n          }\n\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event]);\n            }\n\n            this.parent.release(connection);\n            hasReturned = true;\n\n            if (error) {\n              debug('request(%d): failed', IDS.get(this), error);\n            } else {\n              debug('request(%d): complete', IDS.get(this));\n            }\n\n            if (this.stream) {\n              callback(null, null, output, returnValue, rowsAffected);\n            } else {\n              callback(error, recordsets, output, returnValue, rowsAffected);\n            }\n          }\n        });\n\n        this._setCurrentRequest(req);\n\n        req.on('columnMetadata', metadata => {\n          columns = createColumns(metadata);\n          isChunkedRecordset = false;\n\n          if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n            isChunkedRecordset = true;\n            chunksBuffer = [];\n          }\n\n          if (this.stream) this.emit('recordset', columns);\n        });\n        req.on('row', columns => {\n          if (!recordset) recordset = [];\n\n          if (isChunkedRecordset) {\n            return chunksBuffer.push(columns[0].value);\n          }\n\n          row = {};\n\n          for (const col of columns) {\n            col.value = valueCorrection(col.value, col.metadata);\n            const exi = row[col.metadata.colName];\n\n            if (exi != null) {\n              if (exi instanceof Array) {\n                exi.push(col.value);\n              } else {\n                row[col.metadata.colName] = [exi, col.value];\n              }\n            } else {\n              row[col.metadata.colName] = col.value;\n            }\n          }\n\n          if (this.stream) {\n            this.emit('row', row);\n          } else {\n            recordset.push(row);\n          }\n        });\n        req.on('doneInProc', (rowCount, more) => {\n          if (rowCount != null) rowsAffected.push(rowCount); // filter empty recordsets when NOCOUNT is OFF\n\n          if (Object.keys(columns).length === 0) return;\n\n          if (isChunkedRecordset) {\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n              try {\n                if (chunksBuffer.length === 0) {\n                  row = null;\n                } else {\n                  row = JSON.parse(chunksBuffer.join(''));\n                }\n              } catch (ex) {\n                row = null;\n                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON');\n                if (this.stream) this.emit('error', ex2); // we must collect errors even in stream mode\n\n                errors.push(ex2);\n              }\n            } else {\n              row = {};\n              row[Object.keys(columns)[0]] = chunksBuffer.join('');\n            }\n\n            chunksBuffer = null;\n\n            if (this.stream) {\n              this.emit('row', row);\n            } else {\n              recordset.push(row);\n            }\n          }\n\n          if (!this.stream) {\n            // all rows of current recordset loaded\n            Object.defineProperty(recordset, 'columns', {\n              enumerable: false,\n              configurable: true,\n              value: columns\n            });\n            Object.defineProperty(recordset, 'toTable', {\n              enumerable: false,\n              configurable: true,\n\n              value(name) {\n                return Table.fromRecordset(this, name);\n              }\n\n            });\n            recordsets.push(recordset);\n          }\n\n          recordset = [];\n          columns = {};\n        });\n        req.on('doneProc', (rowCount, more, returnStatus) => {\n          returnValue = returnStatus;\n        });\n        req.on('returnValue', (parameterName, value, metadata) => {\n          output[parameterName] = value;\n        });\n\n        for (const name in this.parameters) {\n          if (!objectHasProperty(this.parameters, name)) {\n            continue;\n          }\n\n          const param = this.parameters[name];\n\n          if (param.io === 1) {\n            req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n              length: param.length,\n              scale: param.scale,\n              precision: param.precision\n            });\n          } else {\n            req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n              length: param.length,\n              scale: param.scale,\n              precision: param.precision\n            });\n          }\n        }\n\n        connection.callProcedure(req);\n      });\n    });\n  }\n\n  _pause() {\n    super._pause();\n\n    if (this._currentRequest) {\n      this._currentRequest.pause();\n    }\n  }\n\n  _resume() {\n    super._resume();\n\n    if (this._currentRequest) {\n      this._currentRequest.resume();\n    }\n  }\n\n}\n\nmodule.exports = Request;","map":{"version":3,"sources":["C:/Projects/sqlsample/node_modules/mssql/lib/tedious/request.js"],"names":["tds","require","debug","BaseRequest","RequestError","IDS","objectHasProperty","TYPES","DECLARATIONS","declare","cast","Table","PARSERS","UDT","JSON_COLUMN_ID","XML_COLUMN_ID","N_TYPES","BitN","DateTimeN","DecimalN","FloatN","IntN","MoneyN","NumericN","getTediousType","type","VarChar","NVarChar","Text","Int","BigInt","TinyInt","SmallInt","Bit","Float","Decimal","Numeric","Real","Money","SmallMoney","Time","Date","DateTime","DateTime2","DateTimeOffset","SmallDateTime","UniqueIdentifier","Xml","Char","NChar","NText","Image","Binary","VarBinary","Geography","Geometry","TVP","Variant","getMssqlType","length","undefined","id","createColumns","metadata","out","index","column","colName","name","dataLength","scale","precision","nullable","flags","caseSensitive","identity","readOnly","udtInfo","udt","typeName","database","dbname","schema","owningSchema","assembly","assemblyName","valueCorrection","value","parameterCorrection","tvp","columns","rows","col","push","Request","_batch","batch","callback","_isBatch","_query","_bulk","table","options","err","_makeBulk","charAt","errors","errorHandlers","hasReturned","handleError","doReturn","connection","info","Error","message","stream","emit","event","removeListener","parent","release","handleInfo","msg","number","state","class","lineNumber","serverName","procName","acquire","get","canceled","_cancel","cancel","on","infoMessage","errorMessage","bind","error","done","rowCount","pop","precedingErrors","bulk","newBulkLoad","path","addColumn","row","addRow","create","objectid","temporary","req","replace","execBulkLoad","_setCurrentRequest","execSqlBatch","command","recordsets","output","rowsAffected","recordset","batchLastRow","batchHasOutput","isChunkedRecordset","chunksBuffer","config","___return___","doneHandler","more","Object","keys","concatenatedChunks","join","parseJSON","JSON","parse","ex","ex2","defineProperty","enumerable","configurable","fromRecordset","parameterName","exi","Array","parameters","param","validate","TypeError","declarations","assigns","selects","io","sqlTextOrProcedure","addParameter","addOutputParameter","_execute","procedure","returnValue","enabled","params","map","k","logValue","s","substring","logName","logParams","forEach","p","returnStatus","callProcedure","_pause","_currentRequest","pause","_resume","resume","module","exports"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst tds = require('tedious')\r\nconst debug = require('debug')('mssql:tedi')\r\nconst BaseRequest = require('../base/request')\r\nconst RequestError = require('../error/request-error')\r\nconst { IDS, objectHasProperty } = require('../utils')\r\nconst { TYPES, DECLARATIONS, declare, cast } = require('../datatypes')\r\nconst Table = require('../table')\r\nconst { PARSERS: UDT } = require('../udt')\r\n\r\nconst JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B'\r\nconst XML_COLUMN_ID = 'XML_F52E2B61-18A1-11d1-B105-00805F49916B'\r\n\r\nconst N_TYPES = {\r\n  BitN: 0x68,\r\n  DateTimeN: 0x6F,\r\n  DecimalN: 0x6A,\r\n  FloatN: 0x6D,\r\n  IntN: 0x26,\r\n  MoneyN: 0x6E,\r\n  NumericN: 0x6C\r\n}\r\n\r\nconst getTediousType = function (type) {\r\n  switch (type) {\r\n    case TYPES.VarChar: return tds.TYPES.VarChar\r\n    case TYPES.NVarChar: return tds.TYPES.NVarChar\r\n    case TYPES.Text: return tds.TYPES.Text\r\n    case TYPES.Int: return tds.TYPES.Int\r\n    case TYPES.BigInt: return tds.TYPES.BigInt\r\n    case TYPES.TinyInt: return tds.TYPES.TinyInt\r\n    case TYPES.SmallInt: return tds.TYPES.SmallInt\r\n    case TYPES.Bit: return tds.TYPES.Bit\r\n    case TYPES.Float: return tds.TYPES.Float\r\n    case TYPES.Decimal: return tds.TYPES.Decimal\r\n    case TYPES.Numeric: return tds.TYPES.Numeric\r\n    case TYPES.Real: return tds.TYPES.Real\r\n    case TYPES.Money: return tds.TYPES.Money\r\n    case TYPES.SmallMoney: return tds.TYPES.SmallMoney\r\n    case TYPES.Time: return tds.TYPES.Time\r\n    case TYPES.Date: return tds.TYPES.Date\r\n    case TYPES.DateTime: return tds.TYPES.DateTime\r\n    case TYPES.DateTime2: return tds.TYPES.DateTime2\r\n    case TYPES.DateTimeOffset: return tds.TYPES.DateTimeOffset\r\n    case TYPES.SmallDateTime: return tds.TYPES.SmallDateTime\r\n    case TYPES.UniqueIdentifier: return tds.TYPES.UniqueIdentifier\r\n    case TYPES.Xml: return tds.TYPES.NVarChar\r\n    case TYPES.Char: return tds.TYPES.Char\r\n    case TYPES.NChar: return tds.TYPES.NChar\r\n    case TYPES.NText: return tds.TYPES.NVarChar\r\n    case TYPES.Image: return tds.TYPES.Image\r\n    case TYPES.Binary: return tds.TYPES.Binary\r\n    case TYPES.VarBinary: return tds.TYPES.VarBinary\r\n    case TYPES.UDT: case TYPES.Geography: case TYPES.Geometry: return tds.TYPES.UDT\r\n    case TYPES.TVP: return tds.TYPES.TVP\r\n    case TYPES.Variant: return tds.TYPES.Variant\r\n    default: return type\r\n  }\r\n}\r\n\r\nconst getMssqlType = function (type, length) {\r\n  if (typeof type !== 'object') return undefined\r\n\r\n  switch (type) {\r\n    case tds.TYPES.Char: return TYPES.Char\r\n    case tds.TYPES.NChar: return TYPES.NChar\r\n    case tds.TYPES.VarChar: return TYPES.VarChar\r\n    case tds.TYPES.NVarChar: return TYPES.NVarChar\r\n    case tds.TYPES.Text: return TYPES.Text\r\n    case tds.TYPES.NText: return TYPES.NText\r\n    case tds.TYPES.Int: return TYPES.Int\r\n    case tds.TYPES.BigInt: return TYPES.BigInt\r\n    case tds.TYPES.TinyInt: return TYPES.TinyInt\r\n    case tds.TYPES.SmallInt: return TYPES.SmallInt\r\n    case tds.TYPES.Bit: return TYPES.Bit\r\n    case tds.TYPES.Float: return TYPES.Float\r\n    case tds.TYPES.Real: return TYPES.Real\r\n    case tds.TYPES.Money: return TYPES.Money\r\n    case tds.TYPES.SmallMoney: return TYPES.SmallMoney\r\n    case tds.TYPES.Numeric: return TYPES.Numeric\r\n    case tds.TYPES.Decimal: return TYPES.Decimal\r\n    case tds.TYPES.DateTime: return TYPES.DateTime\r\n    case tds.TYPES.Time: return TYPES.Time\r\n    case tds.TYPES.Date: return TYPES.Date\r\n    case tds.TYPES.DateTime2: return TYPES.DateTime2\r\n    case tds.TYPES.DateTimeOffset: return TYPES.DateTimeOffset\r\n    case tds.TYPES.SmallDateTime: return TYPES.SmallDateTime\r\n    case tds.TYPES.UniqueIdentifier: return TYPES.UniqueIdentifier\r\n    case tds.TYPES.Image: return TYPES.Image\r\n    case tds.TYPES.Binary: return TYPES.Binary\r\n    case tds.TYPES.VarBinary: return TYPES.VarBinary\r\n    case tds.TYPES.Xml: return TYPES.Xml\r\n    case tds.TYPES.UDT: return TYPES.UDT\r\n    case tds.TYPES.TVP: return TYPES.TVP\r\n    case tds.TYPES.Variant: return TYPES.Variant\r\n    default:\r\n      switch (type.id) {\r\n        case N_TYPES.BitN: return TYPES.Bit\r\n        case N_TYPES.NumericN: return TYPES.Numeric\r\n        case N_TYPES.DecimalN: return TYPES.Decimal\r\n        case N_TYPES.IntN:\r\n          if (length === 8) return TYPES.BigInt\r\n          if (length === 4) return TYPES.Int\r\n          if (length === 2) return TYPES.SmallInt\r\n          return TYPES.TinyInt\r\n        case N_TYPES.FloatN:\r\n          if (length === 8) return TYPES.Float\r\n          return TYPES.Real\r\n        case N_TYPES.MoneyN:\r\n          if (length === 8) return TYPES.Money\r\n          return TYPES.SmallMoney\r\n        case N_TYPES.DateTimeN:\r\n          if (length === 8) return TYPES.DateTime\r\n          return TYPES.SmallDateTime\r\n      }\r\n  }\r\n}\r\n\r\nconst createColumns = function (metadata) {\r\n  const out = {}\r\n  for (let index = 0, length = metadata.length; index < length; index++) {\r\n    const column = metadata[index]\r\n    out[column.colName] = {\r\n      index,\r\n      name: column.colName,\r\n      length: column.dataLength,\r\n      type: getMssqlType(column.type, column.dataLength),\r\n      scale: column.scale,\r\n      precision: column.precision,\r\n      nullable: !!(column.flags & 0x01),\r\n      caseSensitive: !!(column.flags & 0x02),\r\n      identity: !!(column.flags & 0x10),\r\n      readOnly: !(column.flags & 0x0C)\r\n    }\r\n\r\n    if (column.udtInfo) {\r\n      out[column.colName].udt = {\r\n        name: column.udtInfo.typeName,\r\n        database: column.udtInfo.dbname,\r\n        schema: column.udtInfo.owningSchema,\r\n        assembly: column.udtInfo.assemblyName\r\n      }\r\n\r\n      if (DECLARATIONS[column.udtInfo.typeName]) {\r\n        out[column.colName].type = DECLARATIONS[column.udtInfo.typeName]\r\n      }\r\n    }\r\n  }\r\n\r\n  return out\r\n}\r\n\r\nconst valueCorrection = function (value, metadata) {\r\n  if ((metadata.type === tds.TYPES.UDT) && (value != null)) {\r\n    if (UDT[metadata.udtInfo.typeName]) {\r\n      return UDT[metadata.udtInfo.typeName](value)\r\n    } else {\r\n      return value\r\n    }\r\n  } else {\r\n    return value\r\n  }\r\n}\r\n\r\nconst parameterCorrection = function (value) {\r\n  if (value instanceof Table) {\r\n    const tvp = {\r\n      name: value.name,\r\n      schema: value.schema,\r\n      columns: [],\r\n      rows: value.rows\r\n    }\r\n\r\n    for (const col of value.columns) {\r\n      tvp.columns.push({\r\n        name: col.name,\r\n        type: getTediousType(col.type),\r\n        length: col.length,\r\n        scale: col.scale,\r\n        precision: col.precision\r\n      })\r\n    }\r\n\r\n    return tvp\r\n  } else {\r\n    return value\r\n  }\r\n}\r\n\r\nclass Request extends BaseRequest {\r\n  /*\r\n  Execute specified sql batch.\r\n  */\r\n\r\n  _batch (batch, callback) {\r\n    this._isBatch = true\r\n    this._query(batch, callback)\r\n  }\r\n\r\n  /*\r\n  Bulk load.\r\n  */\r\n\r\n  _bulk (table, options, callback) {\r\n    super._bulk(table, options, err => {\r\n      if (err) return callback(err)\r\n\r\n      table._makeBulk()\r\n\r\n      if (!table.name) {\r\n        return callback(new RequestError('Table name must be specified for bulk insert.', 'ENAME'))\r\n      }\r\n\r\n      if (table.name.charAt(0) === '@') {\r\n        return callback(new RequestError(\"You can't use table variables for bulk insert.\", 'ENAME'))\r\n      }\r\n\r\n      const errors = []\r\n      const errorHandlers = {}\r\n      let hasReturned = false\r\n\r\n      const handleError = (doReturn, connection, info) => {\r\n        let err = new Error(info.message)\r\n        err.info = info\r\n        err = new RequestError(err, 'EREQUEST')\r\n\r\n        if (this.stream) {\r\n          this.emit('error', err)\r\n        } else {\r\n          if (doReturn && !hasReturned) {\r\n            if (connection) {\r\n              for (const event in errorHandlers) {\r\n                connection.removeListener(event, errorHandlers[event])\r\n              }\r\n\r\n              this.parent.release(connection)\r\n            }\r\n\r\n            hasReturned = true\r\n            callback(err)\r\n          }\r\n        }\r\n\r\n        // we must collect errors even in stream mode\r\n        errors.push(err)\r\n      }\r\n\r\n      const handleInfo = msg => {\r\n        this.emit('info', {\r\n          message: msg.message,\r\n          number: msg.number,\r\n          state: msg.state,\r\n          class: msg.class,\r\n          lineNumber: msg.lineNumber,\r\n          serverName: msg.serverName,\r\n          procName: msg.procName\r\n        })\r\n      }\r\n\r\n      this.parent.acquire(this, (err, connection) => {\r\n        if (err) return callback(err)\r\n\r\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this))\r\n\r\n        if (this.canceled) {\r\n          debug('request(%d): canceled', IDS.get(this))\r\n          this.parent.release(connection)\r\n          return callback(new RequestError('Canceled.', 'ECANCEL'))\r\n        }\r\n\r\n        this._cancel = () => {\r\n          debug('request(%d): cancel', IDS.get(this))\r\n          connection.cancel()\r\n        }\r\n\r\n        // attach handler to handle multiple error messages\r\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)\r\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\r\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\r\n\r\n        const done = (err, rowCount) => {\r\n          // to make sure we handle no-sql errors as well\r\n          if (err && (!errors.length || (errors.length && err.message !== errors[errors.length - 1].message))) {\r\n            err = new RequestError(err, 'EREQUEST')\r\n            if (this.stream) this.emit('error', err)\r\n            errors.push(err)\r\n          }\r\n\r\n          delete this._cancel\r\n\r\n          let error\r\n          if (errors.length && !this.stream) {\r\n            error = errors.pop()\r\n            error.precedingErrors = errors\r\n          }\r\n\r\n          if (!hasReturned) {\r\n            for (const event in errorHandlers) {\r\n              connection.removeListener(event, errorHandlers[event])\r\n            }\r\n\r\n            this.parent.release(connection)\r\n            hasReturned = true\r\n\r\n            if (this.stream) {\r\n              callback(null, rowCount)\r\n            } else {\r\n              callback(error, rowCount)\r\n            }\r\n          }\r\n        }\r\n\r\n        const bulk = connection.newBulkLoad(table.path, options, done)\r\n\r\n        for (const col of table.columns) {\r\n          bulk.addColumn(col.name, getTediousType(col.type), { nullable: col.nullable, length: col.length, scale: col.scale, precision: col.precision })\r\n        }\r\n\r\n        for (const row of table.rows) {\r\n          bulk.addRow(row)\r\n        }\r\n\r\n        if (table.create) {\r\n          const objectid = table.temporary ? `tempdb..[${table.name}]` : table.path\r\n          const req = new tds.Request(`if object_id('${objectid.replace(/'/g, '\\'\\'')}') is null ${table.declare()}`, err => {\r\n            if (err) return done(err)\r\n\r\n            connection.execBulkLoad(bulk)\r\n          })\r\n          this._setCurrentRequest(req)\r\n\r\n          connection.execSqlBatch(req)\r\n        } else {\r\n          connection.execBulkLoad(bulk)\r\n        }\r\n      })\r\n    })\r\n  }\r\n\r\n  /*\r\n  Execute specified sql command.\r\n  */\r\n\r\n  _query (command, callback) {\r\n    super._query(command, err => {\r\n      if (err) return callback(err)\r\n\r\n      const recordsets = []\r\n      const errors = []\r\n      const errorHandlers = {}\r\n      const output = {}\r\n      const rowsAffected = []\r\n\r\n      let columns = {}\r\n      let recordset = []\r\n      let batchLastRow = null\r\n      let batchHasOutput = false\r\n      let isChunkedRecordset = false\r\n      let chunksBuffer = null\r\n      let hasReturned = false\r\n\r\n      const handleError = (doReturn, connection, info) => {\r\n        let err = new Error(info.message)\r\n        err.info = info\r\n        err = new RequestError(err, 'EREQUEST')\r\n\r\n        if (this.stream) {\r\n          this.emit('error', err)\r\n        } else {\r\n          if (doReturn && !hasReturned) {\r\n            if (connection) {\r\n              for (const event in errorHandlers) {\r\n                connection.removeListener(event, errorHandlers[event])\r\n              }\r\n\r\n              this.parent.release(connection)\r\n            }\r\n\r\n            hasReturned = true\r\n            callback(err)\r\n          }\r\n        }\r\n\r\n        // we must collect errors even in stream mode\r\n        errors.push(err)\r\n      }\r\n\r\n      const handleInfo = msg => {\r\n        this.emit('info', {\r\n          message: msg.message,\r\n          number: msg.number,\r\n          state: msg.state,\r\n          class: msg.class,\r\n          lineNumber: msg.lineNumber,\r\n          serverName: msg.serverName,\r\n          procName: msg.procName\r\n        })\r\n      }\r\n\r\n      this.parent.acquire(this, (err, connection, config) => {\r\n        if (err) return callback(err)\r\n\r\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this))\r\n\r\n        let row\r\n\r\n        if (this.canceled) {\r\n          debug('request(%d): canceled', IDS.get(this))\r\n          this.parent.release(connection)\r\n          return callback(new RequestError('Canceled.', 'ECANCEL'))\r\n        }\r\n\r\n        this._cancel = () => {\r\n          debug('request(%d): cancel', IDS.get(this))\r\n          connection.cancel()\r\n        }\r\n\r\n        // attach handler to handle multiple error messages\r\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)\r\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\r\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\r\n\r\n        debug('request(%d): query', IDS.get(this), command)\r\n\r\n        const req = new tds.Request(command, err => {\r\n          // to make sure we handle no-sql errors as well\r\n          if (err && (!errors.length || (errors.length && err.message !== errors[errors.length - 1].message))) {\r\n            err = new RequestError(err, 'EREQUEST')\r\n            if (this.stream) this.emit('error', err)\r\n            errors.push(err)\r\n          }\r\n\r\n          // process batch outputs\r\n          if (batchHasOutput) {\r\n            if (!this.stream) batchLastRow = recordsets.pop()[0]\r\n\r\n            for (const name in batchLastRow) {\r\n              const value = batchLastRow[name]\r\n              if (name !== '___return___') {\r\n                output[name] = value\r\n              }\r\n            }\r\n          }\r\n\r\n          delete this._cancel\r\n\r\n          let error\r\n          if (errors.length && !this.stream) {\r\n            error = errors.pop()\r\n            error.precedingErrors = errors\r\n          }\r\n\r\n          if (!hasReturned) {\r\n            for (const event in errorHandlers) {\r\n              connection.removeListener(event, errorHandlers[event])\r\n            }\r\n\r\n            this.parent.release(connection)\r\n            hasReturned = true\r\n\r\n            if (error) {\r\n              debug('request(%d): failed', IDS.get(this), error)\r\n            } else {\r\n              debug('request(%d): completed', IDS.get(this))\r\n            }\r\n\r\n            if (this.stream) {\r\n              callback(null, null, output, rowsAffected)\r\n            } else {\r\n              callback(error, recordsets, output, rowsAffected)\r\n            }\r\n          }\r\n        })\r\n\r\n        this._setCurrentRequest(req)\r\n\r\n        req.on('columnMetadata', metadata => {\r\n          columns = createColumns(metadata)\r\n\r\n          isChunkedRecordset = false\r\n          if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\r\n            isChunkedRecordset = true\r\n            chunksBuffer = []\r\n          }\r\n\r\n          if (this.stream) {\r\n            if (this._isBatch) {\r\n              // don't stream recordset with output values in batches\r\n              if (!columns.___return___) {\r\n                this.emit('recordset', columns)\r\n              }\r\n            } else {\r\n              this.emit('recordset', columns)\r\n            }\r\n          }\r\n        })\r\n\r\n        const doneHandler = (rowCount, more) => {\r\n          if (rowCount != null) rowsAffected.push(rowCount)\r\n          // this function is called even when select only set variables so we should skip adding a new recordset\r\n          if (Object.keys(columns).length === 0) return\r\n\r\n          if (isChunkedRecordset) {\r\n            const concatenatedChunks = chunksBuffer.join('')\r\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\r\n              try {\r\n                if (concatenatedChunks === '') {\r\n                  row = null\r\n                } else {\r\n                  row = JSON.parse(concatenatedChunks)\r\n                }\r\n              } catch (ex) {\r\n                row = null\r\n                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON')\r\n\r\n                if (this.stream) this.emit('error', ex2)\r\n\r\n                // we must collect errors even in stream mode\r\n                errors.push(ex2)\r\n              }\r\n            } else {\r\n              row = {}\r\n              row[Object.keys(columns)[0]] = concatenatedChunks\r\n            }\r\n\r\n            chunksBuffer = null\r\n\r\n            if (this.stream) {\r\n              this.emit('row', row)\r\n            } else {\r\n              recordset.push(row)\r\n            }\r\n          }\r\n\r\n          if (!this.stream) {\r\n            // all rows of current recordset loaded\r\n            Object.defineProperty(recordset, 'columns', {\r\n              enumerable: false,\r\n              configurable: true,\r\n              value: columns\r\n            })\r\n\r\n            Object.defineProperty(recordset, 'toTable', {\r\n              enumerable: false,\r\n              configurable: true,\r\n              value (name) { return Table.fromRecordset(this, name) }\r\n            })\r\n\r\n            recordsets.push(recordset)\r\n          }\r\n\r\n          recordset = []\r\n          columns = {}\r\n        }\r\n\r\n        req.on('doneInProc', doneHandler) // doneInProc handlers are used in both queries and batches\r\n        req.on('done', doneHandler) // done handlers are used in batches\r\n\r\n        req.on('returnValue', (parameterName, value, metadata) => {\r\n          output[parameterName] = value\r\n        })\r\n\r\n        req.on('row', columns => {\r\n          if (!recordset) recordset = []\r\n\r\n          if (isChunkedRecordset) {\r\n            return chunksBuffer.push(columns[0].value)\r\n          }\r\n\r\n          row = {}\r\n          for (const col of columns) {\r\n            col.value = valueCorrection(col.value, col.metadata)\r\n\r\n            const exi = row[col.metadata.colName]\r\n            if (exi != null) {\r\n              if (exi instanceof Array) {\r\n                exi.push(col.value)\r\n              } else {\r\n                row[col.metadata.colName] = [exi, col.value]\r\n              }\r\n            } else {\r\n              row[col.metadata.colName] = col.value\r\n            }\r\n          }\r\n\r\n          if (this.stream) {\r\n            if (this._isBatch) {\r\n              // dont stream recordset with output values in batches\r\n              if (row.___return___) {\r\n                batchLastRow = row\r\n              } else {\r\n                this.emit('row', row)\r\n              }\r\n            } else {\r\n              this.emit('row', row)\r\n            }\r\n          } else {\r\n            recordset.push(row)\r\n          }\r\n        })\r\n\r\n        if (this._isBatch) {\r\n          if (Object.keys(this.parameters).length) {\r\n            for (const name in this.parameters) {\r\n              if (!objectHasProperty(this.parameters, name)) {\r\n                continue\r\n              }\r\n              const param = this.parameters[name]\r\n              let value = getTediousType(param.type).validate(param.value)\r\n\r\n              if (value instanceof TypeError) {\r\n                value = new RequestError(`Validation failed for parameter '${name}'. ${value.message}`, 'EPARAM')\r\n\r\n                this.parent.release(connection)\r\n                return callback(value)\r\n              }\r\n\r\n              param.value = value\r\n            }\r\n\r\n            const declarations = []\r\n            for (const name in this.parameters) {\r\n              if (!objectHasProperty(this.parameters, name)) {\r\n                continue\r\n              }\r\n              const param = this.parameters[name]\r\n              declarations.push(`@${name} ${declare(param.type, param)}`)\r\n            }\r\n\r\n            const assigns = []\r\n            for (const name in this.parameters) {\r\n              if (!objectHasProperty(this.parameters, name)) {\r\n                continue\r\n              }\r\n              const param = this.parameters[name]\r\n              assigns.push(`@${name} = ${cast(param.value, param.type, param)}`)\r\n            }\r\n\r\n            const selects = []\r\n            for (const name in this.parameters) {\r\n              if (!objectHasProperty(this.parameters, name)) {\r\n                continue\r\n              }\r\n              const param = this.parameters[name]\r\n              if (param.io === 2) {\r\n                selects.push(`@${name} as [${name}]`)\r\n              }\r\n            }\r\n\r\n            batchHasOutput = selects.length > 0\r\n\r\n            req.sqlTextOrProcedure = `declare ${declarations.join(', ')};select ${assigns.join(', ')};${req.sqlTextOrProcedure};${batchHasOutput ? (`select 1 as [___return___], ${selects.join(', ')}`) : ''}`\r\n          }\r\n        } else {\r\n          for (const name in this.parameters) {\r\n            if (!objectHasProperty(this.parameters, name)) {\r\n              continue\r\n            }\r\n            const param = this.parameters[name]\r\n            if (param.io === 1) {\r\n              req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\r\n            } else {\r\n              req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\r\n            }\r\n          }\r\n        }\r\n\r\n        try {\r\n          connection[this._isBatch ? 'execSqlBatch' : 'execSql'](req)\r\n        } catch (error) {\r\n          handleError(true, connection, error)\r\n        }\r\n      })\r\n    })\r\n  }\r\n\r\n  /*\r\n  Execute stored procedure with specified parameters.\r\n  */\r\n\r\n  _execute (procedure, callback) {\r\n    super._execute(procedure, err => {\r\n      if (err) return callback(err)\r\n\r\n      const recordsets = []\r\n      const errors = []\r\n      const errorHandlers = {}\r\n      const output = {}\r\n      const rowsAffected = []\r\n\r\n      let columns = {}\r\n      let recordset = []\r\n      let returnValue = 0\r\n      let isChunkedRecordset = false\r\n      let chunksBuffer = null\r\n      let hasReturned = false\r\n\r\n      const handleError = (doReturn, connection, info) => {\r\n        let err = new Error(info.message)\r\n        err.info = info\r\n        err = new RequestError(err, 'EREQUEST')\r\n\r\n        if (this.stream) {\r\n          this.emit('error', err)\r\n        } else {\r\n          if (doReturn && !hasReturned) {\r\n            if (connection) {\r\n              for (const event in errorHandlers) {\r\n                connection.removeListener(event, errorHandlers[event])\r\n              }\r\n\r\n              this.parent.release(connection)\r\n            }\r\n\r\n            hasReturned = true\r\n            callback(err)\r\n          }\r\n        }\r\n\r\n        // we must collect errors even in stream mode\r\n        errors.push(err)\r\n      }\r\n\r\n      const handleInfo = msg => {\r\n        this.emit('info', {\r\n          message: msg.message,\r\n          number: msg.number,\r\n          state: msg.state,\r\n          class: msg.class,\r\n          lineNumber: msg.lineNumber,\r\n          serverName: msg.serverName,\r\n          procName: msg.procName\r\n        })\r\n      }\r\n\r\n      this.parent.acquire(this, (err, connection, config) => {\r\n        if (err) return callback(err)\r\n\r\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this))\r\n\r\n        let row\r\n\r\n        if (this.canceled) {\r\n          debug('request(%d): canceled', IDS.get(this))\r\n          this.parent.release(connection)\r\n          return callback(new RequestError('Canceled.', 'ECANCEL'))\r\n        }\r\n\r\n        this._cancel = () => {\r\n          debug('request(%d): cancel', IDS.get(this))\r\n          connection.cancel()\r\n        }\r\n\r\n        // attach handler to handle multiple error messages\r\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)\r\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\r\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\r\n\r\n        if (debug.enabled) {\r\n          // log stored procedure executions and provided parameters\r\n          const params = Object.keys(this.parameters).map(k => this.parameters[k])\r\n          // cut long string parameters short to keep log somewhat clean\r\n          const logValue = s => typeof s === 'string' && s.length > 50 ? s.substring(0, 47) + '...' : s\r\n          // format parameter names as 'my_parameter [sql.Int]'\r\n          const logName = param => param.name + ' [sql.' + param.type.name + ']'\r\n          const logParams = {}\r\n          params.forEach(p => { logParams[logName(p)] = logValue(p.value) })\r\n          debug('request(%d): execute %s %O', IDS.get(this), procedure, logParams)\r\n        }\r\n\r\n        const req = new tds.Request(procedure, err => {\r\n          // to make sure we handle no-sql errors as well\r\n          if (err && (!errors.length || (errors.length && err.message !== errors[errors.length - 1].message))) {\r\n            err = new RequestError(err, 'EREQUEST')\r\n            if (this.stream) this.emit('error', err)\r\n            errors.push(err)\r\n          }\r\n\r\n          delete this._cancel\r\n\r\n          let error\r\n          if (errors.length && !this.stream) {\r\n            error = errors.pop()\r\n            error.precedingErrors = errors\r\n          }\r\n\r\n          if (!hasReturned) {\r\n            for (const event in errorHandlers) {\r\n              connection.removeListener(event, errorHandlers[event])\r\n            }\r\n\r\n            this.parent.release(connection)\r\n            hasReturned = true\r\n\r\n            if (error) {\r\n              debug('request(%d): failed', IDS.get(this), error)\r\n            } else {\r\n              debug('request(%d): complete', IDS.get(this))\r\n            }\r\n\r\n            if (this.stream) {\r\n              callback(null, null, output, returnValue, rowsAffected)\r\n            } else {\r\n              callback(error, recordsets, output, returnValue, rowsAffected)\r\n            }\r\n          }\r\n        })\r\n\r\n        this._setCurrentRequest(req)\r\n\r\n        req.on('columnMetadata', metadata => {\r\n          columns = createColumns(metadata)\r\n\r\n          isChunkedRecordset = false\r\n          if ((metadata.length === 1) && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\r\n            isChunkedRecordset = true\r\n            chunksBuffer = []\r\n          }\r\n\r\n          if (this.stream) this.emit('recordset', columns)\r\n        })\r\n\r\n        req.on('row', columns => {\r\n          if (!recordset) recordset = []\r\n\r\n          if (isChunkedRecordset) {\r\n            return chunksBuffer.push(columns[0].value)\r\n          }\r\n\r\n          row = {}\r\n          for (const col of columns) {\r\n            col.value = valueCorrection(col.value, col.metadata)\r\n\r\n            const exi = row[col.metadata.colName]\r\n            if (exi != null) {\r\n              if (exi instanceof Array) {\r\n                exi.push(col.value)\r\n              } else {\r\n                row[col.metadata.colName] = [exi, col.value]\r\n              }\r\n            } else {\r\n              row[col.metadata.colName] = col.value\r\n            }\r\n          }\r\n\r\n          if (this.stream) {\r\n            this.emit('row', row)\r\n          } else {\r\n            recordset.push(row)\r\n          }\r\n        })\r\n\r\n        req.on('doneInProc', (rowCount, more) => {\r\n          if (rowCount != null) rowsAffected.push(rowCount)\r\n\r\n          // filter empty recordsets when NOCOUNT is OFF\r\n          if (Object.keys(columns).length === 0) return\r\n\r\n          if (isChunkedRecordset) {\r\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\r\n              try {\r\n                if (chunksBuffer.length === 0) {\r\n                  row = null\r\n                } else {\r\n                  row = JSON.parse(chunksBuffer.join(''))\r\n                }\r\n              } catch (ex) {\r\n                row = null\r\n                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON')\r\n\r\n                if (this.stream) this.emit('error', ex2)\r\n\r\n                // we must collect errors even in stream mode\r\n                errors.push(ex2)\r\n              }\r\n            } else {\r\n              row = {}\r\n              row[Object.keys(columns)[0]] = chunksBuffer.join('')\r\n            }\r\n\r\n            chunksBuffer = null\r\n\r\n            if (this.stream) {\r\n              this.emit('row', row)\r\n            } else {\r\n              recordset.push(row)\r\n            }\r\n          }\r\n\r\n          if (!this.stream) {\r\n            // all rows of current recordset loaded\r\n            Object.defineProperty(recordset, 'columns', {\r\n              enumerable: false,\r\n              configurable: true,\r\n              value: columns\r\n            })\r\n\r\n            Object.defineProperty(recordset, 'toTable', {\r\n              enumerable: false,\r\n              configurable: true,\r\n              value (name) { return Table.fromRecordset(this, name) }\r\n            })\r\n\r\n            recordsets.push(recordset)\r\n          }\r\n\r\n          recordset = []\r\n          columns = {}\r\n        })\r\n\r\n        req.on('doneProc', (rowCount, more, returnStatus) => {\r\n          returnValue = returnStatus\r\n        })\r\n\r\n        req.on('returnValue', (parameterName, value, metadata) => {\r\n          output[parameterName] = value\r\n        })\r\n\r\n        for (const name in this.parameters) {\r\n          if (!objectHasProperty(this.parameters, name)) {\r\n            continue\r\n          }\r\n          const param = this.parameters[name]\r\n          if (param.io === 1) {\r\n            req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\r\n          } else {\r\n            req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\r\n          }\r\n        }\r\n\r\n        connection.callProcedure(req)\r\n      })\r\n    })\r\n  }\r\n\r\n  _pause () {\r\n    super._pause()\r\n    if (this._currentRequest) {\r\n      this._currentRequest.pause()\r\n    }\r\n  }\r\n\r\n  _resume () {\r\n    super._resume()\r\n    if (this._currentRequest) {\r\n      this._currentRequest.resume()\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Request\r\n"]},"metadata":{},"sourceType":"script"}